import { __decorate, __metadata } from "tslib";
import { AfterViewInit, ChangeDetectorRef, Component, ComponentFactoryResolver, ElementRef, NgZone, Renderer2, ViewChild, ViewContainerRef } from '@angular/core';
import { PoChartCircular } from '../po-chart-circular/po-chart-circular';
import { poChartGaugeStartAngle } from '../po-chart-circular/po-chart-circular.constant';
import { PoChartGaugeTextContentComponent } from './po-chart-gauge-text-content/po-chart-gauge-text-content.component';
let PoChartGaugeComponent = class PoChartGaugeComponent extends PoChartCircular {
    /* istanbul ignore next */
    constructor(changeDetection, componentFactoryResolver, el, ngZone, renderer) {
        super(el, ngZone, renderer);
        this.changeDetection = changeDetection;
        this.componentFactoryResolver = componentFactoryResolver;
        this.chartItemStartAngle = poChartGaugeStartAngle;
        this._series = [];
    }
    set series(series) {
        this._series = this.getGaugeSerie(series);
    }
    get series() {
        return this._series;
    }
    ngAfterViewInit() {
        this.drawBasePath();
        this.createComponent();
    }
    createComponent() {
        const factory = this.componentFactoryResolver.resolveComponentFactory(PoChartGaugeTextContentComponent);
        const componentRef = this.svgContainerRef.createComponent(factory);
        const instance = componentRef.instance;
        instance.serie = this.series.length && this.series[0];
        instance.gaugeWidth = this.getGaugeBaseWidth();
        this.resizeListenerSubscription(instance);
    }
    checkGaugeValueLimits(value) {
        if (value <= 0) {
            return 0;
        }
        else if (value >= 100) {
            return 100;
        }
        else {
            return value;
        }
    }
    drawBasePath() {
        const basePath = this.el.nativeElement.querySelector('.po-chart-gauge-base-path');
        this.drawPath(basePath, this.chartItemStartAngle, 0);
    }
    getGaugeBaseWidth() {
        const basePath = this.el.nativeElement.querySelector('.po-chart-gauge-base-path');
        if (basePath) {
            return basePath.getBoundingClientRect().width;
        }
    }
    getGaugeSerie(series = []) {
        const [serie] = series;
        if (serie && typeof serie === 'object') {
            return [
                Object.assign(Object.assign({}, serie), { color: this.colors[0], value: this.checkGaugeValueLimits(serie.value) })
            ];
        }
        return [];
    }
    resizeListenerSubscription(instance) {
        this.windowResizeEmitter.subscribe(() => {
            instance.gaugeWidth = this.getGaugeBaseWidth();
            this.changeDetection.detectChanges();
        });
    }
};
PoChartGaugeComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    ViewChild('svgContainer', { static: true, read: ViewContainerRef }),
    __metadata("design:type", ViewContainerRef)
], PoChartGaugeComponent.prototype, "svgContainerRef", void 0);
PoChartGaugeComponent = __decorate([
    Component({
        selector: 'po-chart-gauge',
        template: "<div #chartBody class=\"po-chart-body\">\n  <div #svgContainer class=\"po-chart-svg-container\"></div>\n\n  <div #tooltipElement *ngIf=\"!isChartGaugeType\" class=\"po-chart-tooltip po-tooltip po-invisible\">\n    <div class=\"po-tooltip-arrow po-arrow-bottom\"></div>\n    <div class=\"po-tooltip-content\">{{ tooltipText }}</div>\n  </div>\n</div>\n"
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef,
        ComponentFactoryResolver,
        ElementRef,
        NgZone,
        Renderer2])
], PoChartGaugeComponent);
export { PoChartGaugeComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2hhcnQtZ2F1Z2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHBvLXVpL25nLWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9wby1jaGFydC9wby1jaGFydC10eXBlcy9wby1jaGFydC1nYXVnZS9wby1jaGFydC1nYXVnZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCxhQUFhLEVBQ2IsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCx3QkFBd0IsRUFDeEIsVUFBVSxFQUNWLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNULGdCQUFnQixFQUNqQixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFFekUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0saURBQWlELENBQUM7QUFDekYsT0FBTyxFQUFFLGdDQUFnQyxFQUFFLE1BQU0scUVBQXFFLENBQUM7QUFNdkgsSUFBYSxxQkFBcUIsR0FBbEMsTUFBYSxxQkFBc0IsU0FBUSxlQUFlO0lBZXhELDBCQUEwQjtJQUMxQixZQUNVLGVBQWtDLEVBQ2xDLHdCQUFrRCxFQUMxRCxFQUFjLEVBQ2QsTUFBYyxFQUNkLFFBQW1CO1FBRW5CLEtBQUssQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBTnBCLG9CQUFlLEdBQWYsZUFBZSxDQUFtQjtRQUNsQyw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQTBCO1FBakI1RCx3QkFBbUIsR0FBVyxzQkFBc0IsQ0FBQztRQUUzQyxZQUFPLEdBQTZCLEVBQUUsQ0FBQztJQXFCakQsQ0FBQztJQW5CRCxJQUFJLE1BQU0sQ0FBQyxNQUFnQztRQUN6QyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELElBQUksTUFBTTtRQUNSLE9BQU8s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LFNBQVM7R0FyQlYscUJBQXFCLENBeUZqQztTQXpGWSxxQkFBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gIEVsZW1lbnRSZWYsXG4gIE5nWm9uZSxcbiAgUmVuZGVyZXIyLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFBvQ2hhcnRDaXJjdWxhciB9IGZyb20gJy4uL3BvLWNoYXJ0LWNpcmN1bGFyL3BvLWNoYXJ0LWNpcmN1bGFyJztcbmltcG9ydCB7IFBvQ2hhcnRHYXVnZVNlcmllIH0gZnJvbSAnLi9wby1jaGFydC1nYXVnZS1zZXJpZXMuaW50ZXJmYWNlJztcbmltcG9ydCB7IHBvQ2hhcnRHYXVnZVN0YXJ0QW5nbGUgfSBmcm9tICcuLi9wby1jaGFydC1jaXJjdWxhci9wby1jaGFydC1jaXJjdWxhci5jb25zdGFudCc7XG5pbXBvcnQgeyBQb0NoYXJ0R2F1Z2VUZXh0Q29udGVudENvbXBvbmVudCB9IGZyb20gJy4vcG8tY2hhcnQtZ2F1Z2UtdGV4dC1jb250ZW50L3BvLWNoYXJ0LWdhdWdlLXRleHQtY29udGVudC5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdwby1jaGFydC1nYXVnZScsXG4gIHRlbXBsYXRlVXJsOiAnLi4vcG8tY2hhcnQtZHluYW1pYy10eXBlLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBQb0NoYXJ0R2F1Z2VDb21wb25lbnQgZXh0ZW5kcyBQb0NoYXJ0Q2lyY3VsYXIgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgY2hhcnRJdGVtU3RhcnRBbmdsZTogbnVtYmVyID0gcG9DaGFydEdhdWdlU3RhcnRBbmdsZTtcblxuICBwcm90ZWN0ZWQgX3NlcmllczogQXJyYXk8UG9DaGFydEdhdWdlU2VyaWU+ID0gW107XG5cbiAgc2V0IHNlcmllcyhzZXJpZXM6IEFycmF5PFBvQ2hhcnRHYXVnZVNlcmllPikge1xuICAgIHRoaXMuX3NlcmllcyA9IHRoaXMuZ2V0R2F1Z2VTZXJpZShzZXJpZXMpO1xuICB9XG5cbiAgZ2V0IHNlcmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VyaWVzO1xuICB9XG5cbiAgQFZpZXdDaGlsZCgnc3ZnQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUsIHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSkgc3ZnQ29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcml2YXRlIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIGVsOiBFbGVtZW50UmVmLFxuICAgIG5nWm9uZTogTmdab25lLFxuICAgIHJlbmRlcmVyOiBSZW5kZXJlcjJcbiAgKSB7XG4gICAgc3VwZXIoZWwsIG5nWm9uZSwgcmVuZGVyZXIpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuZHJhd0Jhc2VQYXRoKCk7XG4gICAgdGhpcy5jcmVhdGVDb21wb25lbnQoKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlQ29tcG9uZW50KCkge1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShQb0NoYXJ0R2F1Z2VUZXh0Q29udGVudENvbXBvbmVudCk7XG5cbiAgICBjb25zdCBjb21wb25lbnRSZWYgPSB0aGlzLnN2Z0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoZmFjdG9yeSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjb21wb25lbnRSZWYuaW5zdGFuY2U7XG5cbiAgICBpbnN0YW5jZS5zZXJpZSA9IHRoaXMuc2VyaWVzLmxlbmd0aCAmJiB0aGlzLnNlcmllc1swXTtcbiAgICBpbnN0YW5jZS5nYXVnZVdpZHRoID0gdGhpcy5nZXRHYXVnZUJhc2VXaWR0aCgpO1xuXG4gICAgdGhpcy5yZXNpemVMaXN0ZW5lclN1YnNjcmlwdGlvbihpbnN0YW5jZSk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrR2F1Z2VWYWx1ZUxpbWl0cyh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHZhbHVlIDw9IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPj0gMTAwKSB7XG4gICAgICByZXR1cm4gMTAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkcmF3QmFzZVBhdGgoKSB7XG4gICAgY29uc3QgYmFzZVBhdGggPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnBvLWNoYXJ0LWdhdWdlLWJhc2UtcGF0aCcpO1xuXG4gICAgdGhpcy5kcmF3UGF0aChiYXNlUGF0aCwgdGhpcy5jaGFydEl0ZW1TdGFydEFuZ2xlLCAwKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0R2F1Z2VCYXNlV2lkdGgoKSB7XG4gICAgY29uc3QgYmFzZVBhdGggPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnBvLWNoYXJ0LWdhdWdlLWJhc2UtcGF0aCcpO1xuXG4gICAgaWYgKGJhc2VQYXRoKSB7XG4gICAgICByZXR1cm4gYmFzZVBhdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRHYXVnZVNlcmllKHNlcmllczogQXJyYXk8UG9DaGFydEdhdWdlU2VyaWU+ID0gW10pIHtcbiAgICBjb25zdCBbc2VyaWVdID0gc2VyaWVzO1xuXG4gICAgaWYgKHNlcmllICYmIHR5cGVvZiBzZXJpZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5zZXJpZSxcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcnNbMF0sXG4gICAgICAgICAgdmFsdWU6IHRoaXMuY2hlY2tHYXVnZVZhbHVlTGltaXRzKHNlcmllLnZhbHVlKVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzaXplTGlzdGVuZXJTdWJzY3JpcHRpb24oaW5zdGFuY2U6IFBvQ2hhcnRHYXVnZVRleHRDb250ZW50Q29tcG9uZW50KSB7XG4gICAgdGhpcy53aW5kb3dSZXNpemVFbWl0dGVyLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5nYXVnZVdpZHRoID0gdGhpcy5nZXRHYXVnZUJhc2VXaWR0aCgpO1xuICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24uZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH0pO1xuICB9XG59XG4iXX0=