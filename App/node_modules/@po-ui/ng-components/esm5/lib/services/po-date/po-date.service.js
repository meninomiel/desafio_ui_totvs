import { __decorate, __read, __spread } from "tslib";
import { Injectable } from '@angular/core';
import { sortValues } from '../../utils/util';
/**
 * @docsPrivate
 *
 * @description
 *
 * Serviço responsável por gerenciar o tratamento dos formatos de data e hora.
 */
var PoDateService = /** @class */ (function () {
    function PoDateService() {
        this.dateRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' + '(?:0[1-9]|1[0-2])-' + '(?:0[1-9]|[12]\\d|3[01])$');
        this.isoRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])' +
            'T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|' +
            '-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])' +
            '(?:|:?[0-5]\\d)$');
    }
    /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param minDate Definir `true` caso seja `minDate`.
     * @param maxDate Definir `true` caso seja `maxDate`.
     */
    PoDateService.prototype.convertIsoToDate = function (dateString, minDate, maxDate) {
        if (dateString) {
            var _a = this.getDateFromIso(dateString), year = _a.year, month = _a.month, day = _a.day;
            if (minDate) {
                var date = new Date(year, month - 1, day, 0, 0, 0);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else if (maxDate) {
                var date = new Date(year, month - 1, day, 23, 59, 59);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else {
                var miliseconds = Date.parse(dateString);
                var timezone = new Date().getTimezoneOffset() * 60000;
                return new Date(miliseconds + timezone);
            }
        }
    };
    /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param date Data no formato `Date`.
     */
    PoDateService.prototype.convertDateToISO = function (date) {
        if (date) {
            var fullYear = date.getFullYear();
            var getMonth = date.getMonth() + 1;
            var day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
            var month = getMonth < 10 ? '0' + getMonth : getMonth;
            var year = this.formatYear(fullYear);
            return year + '-' + month + '-' + day;
        }
        else {
            return null;
        }
    };
    /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param year Ano a ser validado.
     */
    PoDateService.prototype.formatYear = function (year) {
        if (year > 999) {
            return year.toString();
        }
        if (year > 99 && year < 1000) {
            return "0" + year;
        }
        if (year > 9 && year < 100) {
            return "00" + year;
        }
        if (year >= 0 && year < 10) {
            return "000" + year;
        }
    };
    /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param isoDate Ano em formato string.
     */
    PoDateService.prototype.getDateFromIso = function (isoDate) {
        var day = parseInt(isoDate.substring(8, 10), 10);
        var month = parseInt(isoDate.substring(5, 7), 10);
        var year = parseInt(isoDate.substring(0, 4), 10);
        return { year: year, month: month, day: day };
    };
    /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     */
    PoDateService.prototype.getDateForDateRange = function (date, isMinDate) {
        var lastHour = isMinDate ? [0, 0, 0] : [23, 59, 59];
        if (date instanceof Date) {
            var _a = this.splitDate(date), year = _a.year, month = _a.month, day = _a.day;
            var validDate = new (Date.bind.apply(Date, __spread([void 0, year, month, day], lastHour)))();
            this.setYearFrom0To100(validDate, year);
            return validDate;
        }
        else if (this.isValidIso(date)) {
            return this.convertIsoToDate(date, isMinDate, !isMinDate);
        }
    };
    /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param dateA primeira data
     * @param dateB segunda data
     */
    PoDateService.prototype.isDateRangeValid = function (dateA, dateB) {
        if (dateA === void 0) { dateA = ''; }
        if (dateB === void 0) { dateB = ''; }
        var dateASplitted = dateA.split('-').map(function (item) { return parseInt(item, 10); });
        var dateBSplitted = dateB.split('-').map(function (item) { return parseInt(item, 10); });
        for (var index = 0; index <= dateASplitted.length; index++) {
            if (dateASplitted[index] > dateBSplitted[index]) {
                return true;
            }
            else if (dateASplitted[index] < dateBSplitted[index]) {
                return false;
            }
        }
        return true;
    };
    /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param stringDate Data.
     */
    PoDateService.prototype.isValidIso = function (stringDate) {
        return this.dateRegex.test(stringDate) || this.isoRegex.test(stringDate);
    };
    /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param date Data.
     * @param year .
     */
    PoDateService.prototype.setYearFrom0To100 = function (date, year) {
        if (year >= 0 && year < 100) {
            date.setFullYear(year);
        }
    };
    /**
     * Método responsável por ordenar duas datas.
     *
     * @param leftSide Primeira data a ser comparada.
     * @param rightSide Segunda data a ser comparada.
     * @param ascending Determina se será em ordem crescente ou decrescente.
     */
    PoDateService.prototype.sortDate = function (leftSide, rightSide, ascending) {
        return sortValues(this.validateDate(leftSide), this.validateDate(rightSide), ascending);
    };
    /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param date Valor da data.
     */
    PoDateService.prototype.splitDate = function (date) {
        var year = date.getFullYear();
        var month = date.getMonth();
        var day = date.getDate();
        return { year: year, month: month, day: day };
    };
    /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param date Data a ser validada.
     * @param minDate Data inicial.
     * @param maxDate Data final.
     */
    PoDateService.prototype.validateDateRange = function (date, minDate, maxDate) {
        if (minDate && maxDate) {
            return date >= minDate && date <= maxDate;
        }
        else if (minDate && !maxDate) {
            return date >= minDate;
        }
        else if (!minDate && maxDate) {
            return date <= maxDate;
        }
        else {
            return true;
        }
    };
    /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @param date Data que será validada.
     */
    PoDateService.prototype.validateDate = function (date) {
        var validDate = date instanceof Date ? this.convertDateToISO(date) : date;
        return this.isValidIso(validDate) ? validDate : undefined;
    };
    PoDateService = __decorate([
        Injectable()
    ], PoDateService);
    return PoDateService;
}());
export { PoDateService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZGF0ZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHBvLXVpL25nLWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvcG8tZGF0ZS9wby1kYXRlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTlDOzs7Ozs7R0FNRztBQUVIO0lBQUE7UUFDbUIsY0FBUyxHQUFHLElBQUksTUFBTSxDQUNyQyxrQ0FBa0MsR0FBRyxvQkFBb0IsR0FBRywyQkFBMkIsQ0FDeEYsQ0FBQztRQUVlLGFBQVEsR0FBRyxJQUFJLE1BQU0sQ0FDcEMsa0NBQWtDO1lBQ2hDLG9CQUFvQjtZQUNwQiwwQkFBMEI7WUFDMUIsa0VBQWtFO1lBQ2xFLGdEQUFnRDtZQUNoRCxrQkFBa0IsQ0FDckIsQ0FBQztJQW9NSixDQUFDO0lBbE1DOzs7Ozs7T0FNRztJQUNILHdDQUFnQixHQUFoQixVQUFpQixVQUFrQixFQUFFLE9BQWdCLEVBQUUsT0FBZ0I7UUFDckUsSUFBSSxVQUFVLEVBQUU7WUFDUixJQUFBLG9DQUFzRCxFQUFwRCxjQUFJLEVBQUUsZ0JBQUssRUFBRSxZQUF1QyxDQUFDO1lBRTdELElBQUksT0FBTyxFQUFFO2dCQUNYLElBQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNyRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNuQyxPQUFPLElBQUksQ0FBQzthQUNiO2lCQUFNLElBQUksT0FBTyxFQUFFO2dCQUNsQixJQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDeEQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbkMsT0FBTyxJQUFJLENBQUM7YUFDYjtpQkFBTTtnQkFDTCxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUMzQyxJQUFNLFFBQVEsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLGlCQUFpQixFQUFFLEdBQUcsS0FBSyxDQUFDO2dCQUN4RCxPQUFPLElBQUksSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsQ0FBQzthQUN6QztTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx3Q0FBZ0IsR0FBaEIsVUFBaUIsSUFBVTtRQUN6QixJQUFJLElBQUksRUFBRTtZQUNSLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNwQyxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3JDLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN4RSxJQUFNLEtBQUssR0FBRyxRQUFRLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFDeEQsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN2QyxPQUFPLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7U0FDdkM7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDO1NBQ2I7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGtDQUFVLEdBQVYsVUFBVyxJQUFZO1FBQ3JCLElBQUksSUFBSSxHQUFHLEdBQUcsRUFBRTtZQUNkLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ3hCO1FBRUQsSUFBSSxJQUFJLEdBQUcsRUFBRSxJQUFJLElBQUksR0FBRyxJQUFJLEVBQUU7WUFDNUIsT0FBTyxNQUFJLElBQU0sQ0FBQztTQUNuQjtRQUVELElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsR0FBRyxFQUFFO1lBQzFCLE9BQU8sT0FBSyxJQUFNLENBQUM7U0FDcEI7UUFFRCxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxHQUFHLEVBQUUsRUFBRTtZQUMxQixPQUFPLFFBQU0sSUFBTSxDQUFDO1NBQ3JCO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxzQ0FBYyxHQUFkLFVBQWUsT0FBZTtRQUM1QixJQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDbkQsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3BELElBQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVuRCxPQUFPLEVBQUUsSUFBSSxNQUFBLEVBQUUsS0FBSyxPQUFBLEVBQUUsR0FBRyxLQUFBLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsMkNBQW1CLEdBQW5CLFVBQW9CLElBQVMsRUFBRSxTQUFrQjtRQUMvQyxJQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3RELElBQUksSUFBSSxZQUFZLElBQUksRUFBRTtZQUNsQixJQUFBLHlCQUEyQyxFQUF6QyxjQUFJLEVBQUUsZ0JBQUssRUFBRSxZQUE0QixDQUFDO1lBQ2xELElBQU0sU0FBUyxRQUFPLElBQUksWUFBSixJQUFJLG9CQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxHQUFLLFFBQVEsS0FBQyxDQUFDO1lBQzFELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDeEMsT0FBTyxTQUFTLENBQUM7U0FDbEI7YUFBTSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDaEMsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzNEO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCx3Q0FBZ0IsR0FBaEIsVUFBaUIsS0FBa0IsRUFBRSxLQUFrQjtRQUF0QyxzQkFBQSxFQUFBLFVBQWtCO1FBQUUsc0JBQUEsRUFBQSxVQUFrQjtRQUNyRCxJQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLElBQUksSUFBSSxPQUFBLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQWxCLENBQWtCLENBQUMsQ0FBQztRQUN2RSxJQUFNLGFBQWEsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLElBQUksSUFBSSxPQUFBLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEVBQWxCLENBQWtCLENBQUMsQ0FBQztRQUV2RSxLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLElBQUksYUFBYSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRTtZQUMxRCxJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsR0FBRyxhQUFhLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQy9DLE9BQU8sSUFBSSxDQUFDO2FBQ2I7aUJBQU0sSUFBSSxhQUFhLENBQUMsS0FBSyxDQUFDLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUN0RCxPQUFPLEtBQUssQ0FBQzthQUNkO1NBQ0Y7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsa0NBQVUsR0FBVixVQUFXLFVBQWtCO1FBQzNCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gseUNBQWlCLEdBQWpCLFVBQWtCLElBQVUsRUFBRSxJQUFZO1FBQ3hDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLEdBQUcsR0FBRyxFQUFFO1lBQzNCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEI7SUFDSCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsZ0NBQVEsR0FBUixVQUFTLFFBQXVCLEVBQUUsU0FBd0IsRUFBRSxTQUFrQjtRQUM1RSxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDMUYsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxpQ0FBUyxHQUFULFVBQVUsSUFBVTtRQUNsQixJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDaEMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzlCLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMzQixPQUFPLEVBQUUsSUFBSSxNQUFBLEVBQUUsS0FBSyxPQUFBLEVBQUUsR0FBRyxLQUFBLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gseUNBQWlCLEdBQWpCLFVBQWtCLElBQVUsRUFBRSxPQUFhLEVBQUUsT0FBYTtRQUN4RCxJQUFJLE9BQU8sSUFBSSxPQUFPLEVBQUU7WUFDdEIsT0FBTyxJQUFJLElBQUksT0FBTyxJQUFJLElBQUksSUFBSSxPQUFPLENBQUM7U0FDM0M7YUFBTSxJQUFJLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUM5QixPQUFPLElBQUksSUFBSSxPQUFPLENBQUM7U0FDeEI7YUFBTSxJQUFJLENBQUMsT0FBTyxJQUFJLE9BQU8sRUFBRTtZQUM5QixPQUFPLElBQUksSUFBSSxPQUFPLENBQUM7U0FDeEI7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDO1NBQ2I7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSyxvQ0FBWSxHQUFwQixVQUFxQixJQUFtQjtRQUN0QyxJQUFNLFNBQVMsR0FBRyxJQUFJLFlBQVksSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUU1RSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQzVELENBQUM7SUEvTVUsYUFBYTtRQUR6QixVQUFVLEVBQUU7T0FDQSxhQUFhLENBZ056QjtJQUFELG9CQUFDO0NBQUEsQUFoTkQsSUFnTkM7U0FoTlksYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgc29ydFZhbHVlcyB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWwnO1xuXG4vKipcbiAqIEBkb2NzUHJpdmF0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFNlcnZpw6dvIHJlc3BvbnPDoXZlbCBwb3IgZ2VyZW5jaWFyIG8gdHJhdGFtZW50byBkb3MgZm9ybWF0b3MgZGUgZGF0YSBlIGhvcmEuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQb0RhdGVTZXJ2aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICdeKD86WzAtOV0pXFxcXGR7MX0oPzpbMC05XSlcXFxcZHsxfS0nICsgJyg/OjBbMS05XXwxWzAtMl0pLScgKyAnKD86MFsxLTldfFsxMl1cXFxcZHwzWzAxXSkkJ1xuICApO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgaXNvUmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICdeKD86WzAtOV0pXFxcXGR7MX0oPzpbMC05XSlcXFxcZHsxfS0nICtcbiAgICAgICcoPzowWzEtOV18MVswLTJdKS0nICtcbiAgICAgICcoPzowWzEtOV18WzEyXVxcXFxkfDNbMDFdKScgK1xuICAgICAgJ1QoPzpbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkOlswLTVdXFxcXGQoPzpafC0wWzEtOV18LTFcXFxcZHwtMlswLTNdfCcgK1xuICAgICAgJy0wMDo/KD86MFsxLTldfFswLTVdXFxcXGQpfFxcXFwrWzAxXVxcXFxkfFxcXFwrMlswLTNdKScgK1xuICAgICAgJyg/Onw6P1swLTVdXFxcXGQpJCdcbiAgKTtcblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGNvbnZlcnRlciBkYXRhcyBkbyBmb3JtYXRvIGB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW1gIHBhcmEgbyBmb3JtYXRvIGBEYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGVTdHJpbmcgRGF0YSBubyBmb3JtYXRvIGB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW1gLlxuICAgKiBAcGFyYW0gbWluRGF0ZSBEZWZpbmlyIGB0cnVlYCBjYXNvIHNlamEgYG1pbkRhdGVgLlxuICAgKiBAcGFyYW0gbWF4RGF0ZSBEZWZpbmlyIGB0cnVlYCBjYXNvIHNlamEgYG1heERhdGVgLlxuICAgKi9cbiAgY29udmVydElzb1RvRGF0ZShkYXRlU3RyaW5nOiBzdHJpbmcsIG1pbkRhdGU6IGJvb2xlYW4sIG1heERhdGU6IGJvb2xlYW4pOiBEYXRlIHtcbiAgICBpZiAoZGF0ZVN0cmluZykge1xuICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSB0aGlzLmdldERhdGVGcm9tSXNvKGRhdGVTdHJpbmcpO1xuXG4gICAgICBpZiAobWluRGF0ZSkge1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIDAsIDAsIDApO1xuICAgICAgICB0aGlzLnNldFllYXJGcm9tMFRvMTAwKGRhdGUsIHllYXIpO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAobWF4RGF0ZSkge1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIDIzLCA1OSwgNTkpO1xuICAgICAgICB0aGlzLnNldFllYXJGcm9tMFRvMTAwKGRhdGUsIHllYXIpO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pbGlzZWNvbmRzID0gRGF0ZS5wYXJzZShkYXRlU3RyaW5nKTtcbiAgICAgICAgY29uc3QgdGltZXpvbmUgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMDtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1pbGlzZWNvbmRzICsgdGltZXpvbmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgY29udmVydGVyIGRhdGEgZG8gZm9ybWF0byBgRGF0ZWAgcGFyYSBvIGZvcm1hdG8gYHl5eXktbW0tZGRgLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZSBEYXRhIG5vIGZvcm1hdG8gYERhdGVgLlxuICAgKi9cbiAgY29udmVydERhdGVUb0lTTyhkYXRlOiBEYXRlKSB7XG4gICAgaWYgKGRhdGUpIHtcbiAgICAgIGNvbnN0IGZ1bGxZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgY29uc3QgZ2V0TW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuICAgICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0RGF0ZSgpIDogZGF0ZS5nZXREYXRlKCk7XG4gICAgICBjb25zdCBtb250aCA9IGdldE1vbnRoIDwgMTAgPyAnMCcgKyBnZXRNb250aCA6IGdldE1vbnRoO1xuICAgICAgY29uc3QgeWVhciA9IHRoaXMuZm9ybWF0WWVhcihmdWxsWWVhcik7XG4gICAgICByZXR1cm4geWVhciArICctJyArIG1vbnRoICsgJy0nICsgZGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGFkaWNpb25hciB6ZXJvcyBhIGVzcXVlcmRhIGRvIGFub3MgZW0gZm9ybWF0byBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB5ZWFyIEFubyBhIHNlciB2YWxpZGFkby5cbiAgICovXG4gIGZvcm1hdFllYXIoeWVhcjogbnVtYmVyKSB7XG4gICAgaWYgKHllYXIgPiA5OTkpIHtcbiAgICAgIHJldHVybiB5ZWFyLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHllYXIgPiA5OSAmJiB5ZWFyIDwgMTAwMCkge1xuICAgICAgcmV0dXJuIGAwJHt5ZWFyfWA7XG4gICAgfVxuXG4gICAgaWYgKHllYXIgPiA5ICYmIHllYXIgPCAxMDApIHtcbiAgICAgIHJldHVybiBgMDAke3llYXJ9YDtcbiAgICB9XG5cbiAgICBpZiAoeWVhciA+PSAwICYmIHllYXIgPCAxMCkge1xuICAgICAgcmV0dXJuIGAwMDAke3llYXJ9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHJldG9ybmFyIG8gZGlhLCBtw6pzIGUgYW5vIHNlcGFyYWRvcyBlbSBmb3JtYXRvIGRlIG9iamV0by5cbiAgICpcbiAgICogQHBhcmFtIGlzb0RhdGUgQW5vIGVtIGZvcm1hdG8gc3RyaW5nLlxuICAgKi9cbiAgZ2V0RGF0ZUZyb21Jc28oaXNvRGF0ZTogc3RyaW5nKTogeyB5ZWFyOiBudW1iZXI7IG1vbnRoOiBudW1iZXI7IGRheTogbnVtYmVyIH0ge1xuICAgIGNvbnN0IGRheSA9IHBhcnNlSW50KGlzb0RhdGUuc3Vic3RyaW5nKDgsIDEwKSwgMTApO1xuICAgIGNvbnN0IG1vbnRoID0gcGFyc2VJbnQoaXNvRGF0ZS5zdWJzdHJpbmcoNSwgNyksIDEwKTtcbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQoaXNvRGF0ZS5zdWJzdHJpbmcoMCwgNCksIDEwKTtcblxuICAgIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgcmV0b3JuYXIgYSBkYXRhIGNvbSBhIGhvcmEgZGVmaW5pZGEgcGFyYSBgMDA6MDA6MDBgIGNhc28gYGlzTWluRGF0ZWAgZm9yIGlndWFsIGEgYHRydWVgIG91IGAyMzo1OTo1OWBcbiAgICogY2FzbyBgaXNNaW5kYXRlYCBzZWphIGlndWFsIGEgYGZhbHNlYCAuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIERhdGEgbm8gZm9ybWF0byBgRGF0ZWAgb3UgYHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbWAuXG4gICAqIEBwYXJhbSBpc01pbkRhdGUgQ2FzbyBgdHJ1ZWAgYXBsaWNhIGAwMDowMDowMGAsIGNhc28gYGZhbHNlYCBhcGxpY2EgYDIzOjU5OjU5YCBhIGhvcmEgZGEgZGF0YSBpbmZvcm1hZGEuXG4gICAqL1xuICBnZXREYXRlRm9yRGF0ZVJhbmdlKGRhdGU6IGFueSwgaXNNaW5EYXRlOiBib29sZWFuKSB7XG4gICAgY29uc3QgbGFzdEhvdXIgPSBpc01pbkRhdGUgPyBbMCwgMCwgMF0gOiBbMjMsIDU5LCA1OV07XG4gICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IHRoaXMuc3BsaXREYXRlKGRhdGUpO1xuICAgICAgY29uc3QgdmFsaWREYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgLi4ubGFzdEhvdXIpO1xuICAgICAgdGhpcy5zZXRZZWFyRnJvbTBUbzEwMCh2YWxpZERhdGUsIHllYXIpO1xuICAgICAgcmV0dXJuIHZhbGlkRGF0ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNWYWxpZElzbyhkYXRlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udmVydElzb1RvRGF0ZShkYXRlLCBpc01pbkRhdGUsICFpc01pbkRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRvcm5hIGB0cnVlYCBjYXNvIG8gcGVyw61vZG8gc2VqYSB2w6FsaWRvLCBwYXJhIGlzc28gYSBwcmltZWlyYSBkYXRhIGRldmUgc2VyIG1haW9yIHF1ZSBhIHNlZ3VuZGEgZGF0YS5cbiAgICogQHBhcmFtIGRhdGVBIHByaW1laXJhIGRhdGFcbiAgICogQHBhcmFtIGRhdGVCIHNlZ3VuZGEgZGF0YVxuICAgKi9cbiAgaXNEYXRlUmFuZ2VWYWxpZChkYXRlQTogc3RyaW5nID0gJycsIGRhdGVCOiBzdHJpbmcgPSAnJyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGRhdGVBU3BsaXR0ZWQgPSBkYXRlQS5zcGxpdCgnLScpLm1hcChpdGVtID0+IHBhcnNlSW50KGl0ZW0sIDEwKSk7XG4gICAgY29uc3QgZGF0ZUJTcGxpdHRlZCA9IGRhdGVCLnNwbGl0KCctJykubWFwKGl0ZW0gPT4gcGFyc2VJbnQoaXRlbSwgMTApKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPD0gZGF0ZUFTcGxpdHRlZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChkYXRlQVNwbGl0dGVkW2luZGV4XSA+IGRhdGVCU3BsaXR0ZWRbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkYXRlQVNwbGl0dGVkW2luZGV4XSA8IGRhdGVCU3BsaXR0ZWRbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgdmFsaWRhciBzZSB1bWEgZGF0YSBlc3TDoSBubyBmb3JtYXRvIGB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW1gIG91IGB5eXl5LW1tLWRkYC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZ0RhdGUgRGF0YS5cbiAgICovXG4gIGlzVmFsaWRJc28oc3RyaW5nRGF0ZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVJlZ2V4LnRlc3Qoc3RyaW5nRGF0ZSkgfHwgdGhpcy5pc29SZWdleC50ZXN0KHN0cmluZ0RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBjb3JyaWdpciBhIGRhdGEgY2FzbyBhIG1lc21hIGVzdGVqYSBlbnRyZSBvcyBhbm9zIDAgZSA5OS5cbiAgICpcbiAgICogQHBhcmFtIGRhdGUgRGF0YS5cbiAgICogQHBhcmFtIHllYXIgLlxuICAgKi9cbiAgc2V0WWVhckZyb20wVG8xMDAoZGF0ZTogRGF0ZSwgeWVhcjogbnVtYmVyKSB7XG4gICAgaWYgKHllYXIgPj0gMCAmJiB5ZWFyIDwgMTAwKSB7XG4gICAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3Igb3JkZW5hciBkdWFzIGRhdGFzLlxuICAgKlxuICAgKiBAcGFyYW0gbGVmdFNpZGUgUHJpbWVpcmEgZGF0YSBhIHNlciBjb21wYXJhZGEuXG4gICAqIEBwYXJhbSByaWdodFNpZGUgU2VndW5kYSBkYXRhIGEgc2VyIGNvbXBhcmFkYS5cbiAgICogQHBhcmFtIGFzY2VuZGluZyBEZXRlcm1pbmEgc2Ugc2Vyw6EgZW0gb3JkZW0gY3Jlc2NlbnRlIG91IGRlY3Jlc2NlbnRlLlxuICAgKi9cbiAgc29ydERhdGUobGVmdFNpZGU6IHN0cmluZyB8IERhdGUsIHJpZ2h0U2lkZTogc3RyaW5nIHwgRGF0ZSwgYXNjZW5kaW5nOiBib29sZWFuKTogbnVtYmVyIHtcbiAgICByZXR1cm4gc29ydFZhbHVlcyh0aGlzLnZhbGlkYXRlRGF0ZShsZWZ0U2lkZSksIHRoaXMudmFsaWRhdGVEYXRlKHJpZ2h0U2lkZSksIGFzY2VuZGluZyk7XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHJldG9ybmFyIG8gZGlhICwgbcOqcyBlIGFubyBkZSB1bWEgZGF0YSBpbmZvcm1hZGEuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIFZhbG9yIGRhIGRhdGEuXG4gICAqL1xuICBzcGxpdERhdGUoZGF0ZTogRGF0ZSkge1xuICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgY29uc3QgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciB2YWxpZGFyIHNlIHVtYSBkYXRhIGVzdMOhIGVudHJlIGEgYG1pbkRhdGVgIGUgYG1heERhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZSBEYXRhIGEgc2VyIHZhbGlkYWRhLlxuICAgKiBAcGFyYW0gbWluRGF0ZSBEYXRhIGluaWNpYWwuXG4gICAqIEBwYXJhbSBtYXhEYXRlIERhdGEgZmluYWwuXG4gICAqL1xuICB2YWxpZGF0ZURhdGVSYW5nZShkYXRlOiBEYXRlLCBtaW5EYXRlOiBEYXRlLCBtYXhEYXRlOiBEYXRlKSB7XG4gICAgaWYgKG1pbkRhdGUgJiYgbWF4RGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUgPj0gbWluRGF0ZSAmJiBkYXRlIDw9IG1heERhdGU7XG4gICAgfSBlbHNlIGlmIChtaW5EYXRlICYmICFtYXhEYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZSA+PSBtaW5EYXRlO1xuICAgIH0gZWxzZSBpZiAoIW1pbkRhdGUgJiYgbWF4RGF0ZSkge1xuICAgICAgcmV0dXJuIGRhdGUgPD0gbWF4RGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciB2YWxpZGFyIHNlIGEgZGF0YSBmb2kgaW5mb3JtYWRhIG5vcyBwYWRyw7VlcyAneXl5eS1tbS1kZCcsICd5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW0nIG91XG4gICAqICdEYXRlJyBwYWRyw6NvIGRvIGphdmFzY3JpcHQuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIERhdGEgcXVlIHNlcsOhIHZhbGlkYWRhLlxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZURhdGUoZGF0ZTogc3RyaW5nIHwgRGF0ZSkge1xuICAgIGNvbnN0IHZhbGlkRGF0ZSA9IGRhdGUgaW5zdGFuY2VvZiBEYXRlID8gdGhpcy5jb252ZXJ0RGF0ZVRvSVNPKGRhdGUpIDogZGF0ZTtcblxuICAgIHJldHVybiB0aGlzLmlzVmFsaWRJc28odmFsaWREYXRlKSA/IHZhbGlkRGF0ZSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuIl19