import { __decorate, __metadata } from "tslib";
import { EventEmitter, Input, Output, Directive } from '@angular/core';
import { PoCalendarLangService } from './services/po-calendar.lang.service';
import { PoDateService } from '../../services/po-date';
var poCalendarLocales = ['pt', 'en', 'es'];
var poCalendarLocaleDefault = 'pt';
/**
 * @description
 *
 * O `po-calendar` é um componente para seleção de datas. Ele permite uma fácil navegação clicando nas setas
 * de direcionamento e nos *labels* do ano ou mês.
 *
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * this.date = '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * this.date = '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * this.date = new Date(2017, 10, 28);
 * ```
 *
 * > Independentemente do formato utilizado, o componente trata o valor do *model* internamente com o
 * formato **Data (E8601DAw.): yyyy-mm-dd**.
 *
 * Importante:
 *
 * - Caso seja definida uma data fora do range da data mínima e data máxima via *ngModel* o componente mostrará
 * a data desabilitada porém o *model* não será alterado.
 * - Caso seja definida uma data inválida a mesma não será atribuída ao calendário porém o *model* manterá a data inválida.
 */
var PoCalendarBaseComponent = /** @class */ (function () {
    function PoCalendarBaseComponent(poDate, poCalendarLangService) {
        this.poDate = poDate;
        this.poCalendarLangService = poCalendarLangService;
        this.dayVisible = false;
        this.displayMonths = Array();
        this.displayWeekDays = Array();
        this.monthVisible = false;
        this.yearVisible = false;
        this.onTouched = null;
        this.propagateChange = null;
        this.today = new Date();
        /** Evento disparado ao selecionar um dia do calendário. */
        this.change = new EventEmitter();
    }
    Object.defineProperty(PoCalendarBaseComponent.prototype, "locale", {
        get: function () {
            return this._locale;
        },
        /**
         * @optional
         *
         * @description
         *
         * Idioma do calendário.
         *
         * Valores válidos:
         *  - `pt`
         *  - `en`
         *  - `es`
         *
         * @default `pt`
         */
        set: function (locale) {
            this._locale = poCalendarLocales.includes(locale) ? locale : poCalendarLocaleDefault;
            this.initializeLanguage();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PoCalendarBaseComponent.prototype, "maxDate", {
        get: function () {
            return this._maxDate;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define a data máxima possível de ser selecionada.
         *
         * Pode receber os seguintes formatos de data:
         *
         * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
         * ```
         * this.date = '2017-11-28T00:00:00-02:00';
         * ```
         *
         * - **Data (E8601DAw.): yyyy-mm-dd**
         * ```
         * this.date = '2017-11-28';
         * ```
         *
         * - **JavaScript Date Object:**
         * ```
         * this.date = new Date(2017, 10, 28);
         * ```
         */
        set: function (maxDate) {
            this._maxDate = this.poDate.getDateForDateRange(maxDate, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PoCalendarBaseComponent.prototype, "minDate", {
        get: function () {
            return this._minDate;
        },
        /**
         * @optional
         *
         * @description
         *
         * Define a data mínima possível de ser selecionada.
         *
         * Pode receber os seguintes formatos de data:
         *
         * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
         * ```
         * this.date = '2017-11-28T00:00:00-02:00';
         * ```
         *
         * - **Data (E8601DAw.): yyyy-mm-dd**
         * ```
         * this.date = '2017-11-28';
         * ```
         *
         * - **JavaScript Date Object:**
         * ```
         * this.date = new Date(2017, 10, 28);
         * ```
         */
        set: function (minDate) {
            this._minDate = this.poDate.getDateForDateRange(minDate, true);
        },
        enumerable: true,
        configurable: true
    });
    PoCalendarBaseComponent.prototype.initializeLanguage = function () {
        this.poCalendarLangService.setLanguage(this.locale);
        this.displayWeekDays = this.poCalendarLangService.getWeekDaysArray();
        this.displayMonths = this.poCalendarLangService.getMonthsArray();
        this.displayMonth = this.displayMonths[this.displayMonthNumber];
    };
    PoCalendarBaseComponent.ctorParameters = function () { return [
        { type: PoDateService },
        { type: PoCalendarLangService }
    ]; };
    __decorate([
        Input('p-locale'),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], PoCalendarBaseComponent.prototype, "locale", null);
    __decorate([
        Input('p-max-date'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], PoCalendarBaseComponent.prototype, "maxDate", null);
    __decorate([
        Input('p-min-date'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], PoCalendarBaseComponent.prototype, "minDate", null);
    __decorate([
        Output('p-change'),
        __metadata("design:type", Object)
    ], PoCalendarBaseComponent.prototype, "change", void 0);
    PoCalendarBaseComponent = __decorate([
        Directive(),
        __metadata("design:paramtypes", [PoDateService, PoCalendarLangService])
    ], PoCalendarBaseComponent);
    return PoCalendarBaseComponent;
}());
export { PoCalendarBaseComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2FsZW5kYXItYmFzZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AcG8tdWkvbmctY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL3BvLWNhbGVuZGFyL3BvLWNhbGVuZGFyLWJhc2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXZFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzVFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUV2RCxJQUFNLGlCQUFpQixHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM3QyxJQUFNLHVCQUF1QixHQUFHLElBQUksQ0FBQztBQUVyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQStCRztBQUVIO0lBbUhFLGlDQUFtQixNQUFxQixFQUFTLHFCQUE0QztRQUExRSxXQUFNLEdBQU4sTUFBTSxDQUFlO1FBQVMsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUF1QjtRQTdHN0YsZUFBVSxHQUFZLEtBQUssQ0FBQztRQU01QixrQkFBYSxHQUFlLEtBQUssRUFBRSxDQUFDO1FBRXBDLG9CQUFlLEdBQWUsS0FBSyxFQUFFLENBQUM7UUFFdEMsaUJBQVksR0FBWSxLQUFLLENBQUM7UUFDOUIsZ0JBQVcsR0FBWSxLQUFLLENBQUM7UUFNbkIsY0FBUyxHQUFRLElBQUksQ0FBQztRQUN0QixvQkFBZSxHQUFRLElBQUksQ0FBQztRQUM1QixVQUFLLEdBQVMsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQXVGbkMsMkRBQTJEO1FBQ3ZDLFdBQU0sR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO0lBRXdDLENBQUM7SUF6RTlFLHNCQUFJLDJDQUFNO2FBSTdCO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3RCLENBQUM7UUFwQkQ7Ozs7Ozs7Ozs7Ozs7V0FhRzthQUNnQixVQUFXLE1BQWM7WUFDMUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsdUJBQXVCLENBQUM7WUFDckYsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDNUIsQ0FBQzs7O09BQUE7SUE2Qm9CLHNCQUFJLDRDQUFPO2FBR2hDO1lBQ0UsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3ZCLENBQUM7UUE3QkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBdUJHO2FBQ2tCLFVBQVksT0FBWTtZQUMzQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2xFLENBQUM7OztPQUFBO0lBNkJvQixzQkFBSSw0Q0FBTzthQUdoQztZQUNFLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUN2QixDQUFDO1FBN0JEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQXVCRzthQUNrQixVQUFZLE9BQVk7WUFDM0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNqRSxDQUFDOzs7T0FBQTtJQVVELG9EQUFrQixHQUFsQjtRQUNFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3BELElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDckUsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDakUsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7O2dCQVAwQixhQUFhO2dCQUFnQyxxQkFBcUI7O0lBekUxRTtRQUFsQixLQUFLLENBQUMsVUFBVSxDQUFDOzs7eURBR2pCO0lBNkJvQjtRQUFwQixLQUFLLENBQUMsWUFBWSxDQUFDOzs7MERBRW5CO0lBNkJvQjtRQUFwQixLQUFLLENBQUMsWUFBWSxDQUFDOzs7MERBRW5CO0lBTW1CO1FBQW5CLE1BQU0sQ0FBQyxVQUFVLENBQUM7OzJEQUFxQztJQWpIN0MsdUJBQXVCO1FBRG5DLFNBQVMsRUFBRTt5Q0FvSGlCLGFBQWEsRUFBZ0MscUJBQXFCO09BbkhsRix1QkFBdUIsQ0EySG5DO0lBQUQsOEJBQUM7Q0FBQSxBQTNIRCxJQTJIQztTQTNIWSx1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQb0NhbGVuZGFyTGFuZ1NlcnZpY2UgfSBmcm9tICcuL3NlcnZpY2VzL3BvLWNhbGVuZGFyLmxhbmcuc2VydmljZSc7XG5pbXBvcnQgeyBQb0RhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcG8tZGF0ZSc7XG5cbmNvbnN0IHBvQ2FsZW5kYXJMb2NhbGVzID0gWydwdCcsICdlbicsICdlcyddO1xuY29uc3QgcG9DYWxlbmRhckxvY2FsZURlZmF1bHQgPSAncHQnO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIE8gYHBvLWNhbGVuZGFyYCDDqSB1bSBjb21wb25lbnRlIHBhcmEgc2VsZcOnw6NvIGRlIGRhdGFzLiBFbGUgcGVybWl0ZSB1bWEgZsOhY2lsIG5hdmVnYcOnw6NvIGNsaWNhbmRvIG5hcyBzZXRhc1xuICogZGUgZGlyZWNpb25hbWVudG8gZSBub3MgKmxhYmVscyogZG8gYW5vIG91IG3DqnMuXG4gKlxuICogRXN0ZSBjb21wb25lbnRlIHBvZGUgcmVjZWJlciBvcyBzZWd1aW50ZXMgZm9ybWF0b3MgZGUgZGF0YTpcbiAqXG4gKiAtICoqRGF0YSBlIGhvcmEgY29tYmluYWRvcyAoRTg2MDFEWncpOiB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW0qKlxuICogYGBgXG4gKiB0aGlzLmRhdGUgPSAnMjAxNy0xMS0yOFQwMDowMDowMC0wMjowMCc7XG4gKiBgYGBcbiAqXG4gKiAtICoqRGF0YSAoRTg2MDFEQXcuKTogeXl5eS1tbS1kZCoqXG4gKiBgYGBcbiAqIHRoaXMuZGF0ZSA9ICcyMDE3LTExLTI4JztcbiAqIGBgYFxuICpcbiAqIC0gKipKYXZhU2NyaXB0IERhdGUgT2JqZWN0OioqXG4gKiBgYGBcbiAqIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKDIwMTcsIDEwLCAyOCk7XG4gKiBgYGBcbiAqXG4gKiA+IEluZGVwZW5kZW50ZW1lbnRlIGRvIGZvcm1hdG8gdXRpbGl6YWRvLCBvIGNvbXBvbmVudGUgdHJhdGEgbyB2YWxvciBkbyAqbW9kZWwqIGludGVybmFtZW50ZSBjb20gb1xuICogZm9ybWF0byAqKkRhdGEgKEU4NjAxREF3Lik6IHl5eXktbW0tZGQqKi5cbiAqXG4gKiBJbXBvcnRhbnRlOlxuICpcbiAqIC0gQ2FzbyBzZWphIGRlZmluaWRhIHVtYSBkYXRhIGZvcmEgZG8gcmFuZ2UgZGEgZGF0YSBtw61uaW1hIGUgZGF0YSBtw6F4aW1hIHZpYSAqbmdNb2RlbCogbyBjb21wb25lbnRlIG1vc3RyYXLDoVxuICogYSBkYXRhIGRlc2FiaWxpdGFkYSBwb3LDqW0gbyAqbW9kZWwqIG7Do28gc2Vyw6EgYWx0ZXJhZG8uXG4gKiAtIENhc28gc2VqYSBkZWZpbmlkYSB1bWEgZGF0YSBpbnbDoWxpZGEgYSBtZXNtYSBuw6NvIHNlcsOhIGF0cmlidcOtZGEgYW8gY2FsZW5kw6FyaW8gcG9yw6ltIG8gKm1vZGVsKiBtYW50ZXLDoSBhIGRhdGEgaW52w6FsaWRhLlxuICovXG5ARGlyZWN0aXZlKClcbmV4cG9ydCBjbGFzcyBQb0NhbGVuZGFyQmFzZUNvbXBvbmVudCB7XG4gIHByaXZhdGUgX2xvY2FsZTogc3RyaW5nO1xuICBwcml2YXRlIF9tYXhEYXRlOiBEYXRlO1xuICBwcml2YXRlIF9taW5EYXRlOiBEYXRlO1xuXG4gIGN1cnJlbnRZZWFyOiBudW1iZXI7XG4gIGRheVZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZGlzcGxheURheXM6IEFycmF5PG51bWJlcj47XG4gIGRpc3BsYXlEZWNhZGU6IEFycmF5PG51bWJlcj47XG4gIGRpc3BsYXlGaW5hbERlY2FkZTogbnVtYmVyO1xuICBkaXNwbGF5TW9udGg6IGFueTtcbiAgZGlzcGxheU1vbnRoTnVtYmVyOiBudW1iZXI7XG4gIGRpc3BsYXlNb250aHM6IEFycmF5PGFueT4gPSBBcnJheSgpO1xuICBkaXNwbGF5U3RhcnREZWNhZGU6IG51bWJlcjtcbiAgZGlzcGxheVdlZWtEYXlzOiBBcnJheTxhbnk+ID0gQXJyYXkoKTtcbiAgZGlzcGxheVllYXI6IG51bWJlcjtcbiAgbW9udGhWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG4gIHllYXJWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJvdGVjdGVkIGN1cnJlbnRNb250aE51bWJlcjogbnVtYmVyO1xuICBwcm90ZWN0ZWQgZGF0ZTogRGF0ZTtcbiAgcHJvdGVjdGVkIGRhdGVJc286IHN0cmluZztcbiAgcHJvdGVjdGVkIGxhc3REaXNwbGF5OiBzdHJpbmc7XG4gIHByb3RlY3RlZCBvblRvdWNoZWQ6IGFueSA9IG51bGw7XG4gIHByb3RlY3RlZCBwcm9wYWdhdGVDaGFuZ2U6IGFueSA9IG51bGw7XG4gIHByb3RlY3RlZCB0b2RheTogRGF0ZSA9IG5ldyBEYXRlKCk7XG4gIHByb3RlY3RlZCB2YWxpZGF0b3JDaGFuZ2U6IGFueTtcblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBJZGlvbWEgZG8gY2FsZW5kw6FyaW8uXG4gICAqXG4gICAqIFZhbG9yZXMgdsOhbGlkb3M6XG4gICAqICAtIGBwdGBcbiAgICogIC0gYGVuYFxuICAgKiAgLSBgZXNgXG4gICAqXG4gICAqIEBkZWZhdWx0IGBwdGBcbiAgICovXG4gIEBJbnB1dCgncC1sb2NhbGUnKSBzZXQgbG9jYWxlKGxvY2FsZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fbG9jYWxlID0gcG9DYWxlbmRhckxvY2FsZXMuaW5jbHVkZXMobG9jYWxlKSA/IGxvY2FsZSA6IHBvQ2FsZW5kYXJMb2NhbGVEZWZhdWx0O1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxhbmd1YWdlKCk7XG4gIH1cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRGVmaW5lIGEgZGF0YSBtw6F4aW1hIHBvc3PDrXZlbCBkZSBzZXIgc2VsZWNpb25hZGEuXG4gICAqXG4gICAqIFBvZGUgcmVjZWJlciBvcyBzZWd1aW50ZXMgZm9ybWF0b3MgZGUgZGF0YTpcbiAgICpcbiAgICogLSAqKkRhdGEgZSBob3JhIGNvbWJpbmFkb3MgKEU4NjAxRFp3KTogeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tKipcbiAgICogYGBgXG4gICAqIHRoaXMuZGF0ZSA9ICcyMDE3LTExLTI4VDAwOjAwOjAwLTAyOjAwJztcbiAgICogYGBgXG4gICAqXG4gICAqIC0gKipEYXRhIChFODYwMURBdy4pOiB5eXl5LW1tLWRkKipcbiAgICogYGBgXG4gICAqIHRoaXMuZGF0ZSA9ICcyMDE3LTExLTI4JztcbiAgICogYGBgXG4gICAqXG4gICAqIC0gKipKYXZhU2NyaXB0IERhdGUgT2JqZWN0OioqXG4gICAqIGBgYFxuICAgKiB0aGlzLmRhdGUgPSBuZXcgRGF0ZSgyMDE3LCAxMCwgMjgpO1xuICAgKiBgYGBcbiAgICovXG4gIEBJbnB1dCgncC1tYXgtZGF0ZScpIHNldCBtYXhEYXRlKG1heERhdGU6IGFueSkge1xuICAgIHRoaXMuX21heERhdGUgPSB0aGlzLnBvRGF0ZS5nZXREYXRlRm9yRGF0ZVJhbmdlKG1heERhdGUsIGZhbHNlKTtcbiAgfVxuICBnZXQgbWF4RGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4RGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBhIGRhdGEgbcOtbmltYSBwb3Nzw612ZWwgZGUgc2VyIHNlbGVjaW9uYWRhLlxuICAgKlxuICAgKiBQb2RlIHJlY2ViZXIgb3Mgc2VndWludGVzIGZvcm1hdG9zIGRlIGRhdGE6XG4gICAqXG4gICAqIC0gKipEYXRhIGUgaG9yYSBjb21iaW5hZG9zIChFODYwMURadyk6IHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbSoqXG4gICAqIGBgYFxuICAgKiB0aGlzLmRhdGUgPSAnMjAxNy0xMS0yOFQwMDowMDowMC0wMjowMCc7XG4gICAqIGBgYFxuICAgKlxuICAgKiAtICoqRGF0YSAoRTg2MDFEQXcuKTogeXl5eS1tbS1kZCoqXG4gICAqIGBgYFxuICAgKiB0aGlzLmRhdGUgPSAnMjAxNy0xMS0yOCc7XG4gICAqIGBgYFxuICAgKlxuICAgKiAtICoqSmF2YVNjcmlwdCBEYXRlIE9iamVjdDoqKlxuICAgKiBgYGBcbiAgICogdGhpcy5kYXRlID0gbmV3IERhdGUoMjAxNywgMTAsIDI4KTtcbiAgICogYGBgXG4gICAqL1xuICBASW5wdXQoJ3AtbWluLWRhdGUnKSBzZXQgbWluRGF0ZShtaW5EYXRlOiBhbnkpIHtcbiAgICB0aGlzLl9taW5EYXRlID0gdGhpcy5wb0RhdGUuZ2V0RGF0ZUZvckRhdGVSYW5nZShtaW5EYXRlLCB0cnVlKTtcbiAgfVxuICBnZXQgbWluRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWluRGF0ZTtcbiAgfVxuXG4gIC8qKiBFdmVudG8gZGlzcGFyYWRvIGFvIHNlbGVjaW9uYXIgdW0gZGlhIGRvIGNhbGVuZMOhcmlvLiAqL1xuICBAT3V0cHV0KCdwLWNoYW5nZScpIGNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwb0RhdGU6IFBvRGF0ZVNlcnZpY2UsIHB1YmxpYyBwb0NhbGVuZGFyTGFuZ1NlcnZpY2U6IFBvQ2FsZW5kYXJMYW5nU2VydmljZSkge31cblxuICBpbml0aWFsaXplTGFuZ3VhZ2UoKSB7XG4gICAgdGhpcy5wb0NhbGVuZGFyTGFuZ1NlcnZpY2Uuc2V0TGFuZ3VhZ2UodGhpcy5sb2NhbGUpO1xuICAgIHRoaXMuZGlzcGxheVdlZWtEYXlzID0gdGhpcy5wb0NhbGVuZGFyTGFuZ1NlcnZpY2UuZ2V0V2Vla0RheXNBcnJheSgpO1xuICAgIHRoaXMuZGlzcGxheU1vbnRocyA9IHRoaXMucG9DYWxlbmRhckxhbmdTZXJ2aWNlLmdldE1vbnRoc0FycmF5KCk7XG4gICAgdGhpcy5kaXNwbGF5TW9udGggPSB0aGlzLmRpc3BsYXlNb250aHNbdGhpcy5kaXNwbGF5TW9udGhOdW1iZXJdO1xuICB9XG59XG4iXX0=