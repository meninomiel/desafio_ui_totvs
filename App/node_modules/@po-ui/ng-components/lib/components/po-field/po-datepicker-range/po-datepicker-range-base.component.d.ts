import { AbstractControl, ControlValueAccessor, ValidationErrors, Validator } from '@angular/forms';
import { EventEmitter } from '@angular/core';
import { PoDatepickerRange } from './interfaces/po-datepicker-range.interface';
import { PoDatepickerRangeLiterals } from './interfaces/po-datepicker-range-literals.interface';
import { PoDateService } from './../../../services/po-date/po-date.service';
import * as ɵngcc0 from '@angular/core';
export declare const poDatepickerRangeLiteralsDefault: {
    en: PoDatepickerRangeLiterals;
    es: PoDatepickerRangeLiterals;
    pt: PoDatepickerRangeLiterals;
    ru: PoDatepickerRangeLiterals;
};
/**
 * @description
 *
 * O `po-datepicker-range` é um componente para seleção de um período entre duas datas, onde é possível informar apenas
 * a data inicial ou a data final.
 *
 * O componente `[(ngModel)]` do `po-datepicker-range` trabalha com um objeto que implementa a interface
 * `PoDatepickerRange`, contendo as seguintes propriedades:
 * ```
 * { "start": '2017-11-28', "end": '2017-11-30' }
 * ```
 *
 * <a id="accepted-formats"></a>
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * new Date(2017, 10, 28);
 * ```
 *
 * > O componente respeitará o formato passado para o *model* via codificação. Porém, caso seja feita alteração em algum
 * dos valores de data em tela, o componente atribuirá o formato **Data (E8601DAw.): yyyy-mm-dd** ao model.
 *
 * Importante:
 *
 * - Quando preenchidas a data inicial e final, a data inicial deve ser sempre menor ou igual a data final;
 * - Ao passar uma data inválida via codificação, o valor será mantido no *model* e o `input` da tela aparecerá vazio;
 * - Permite trabalhar com as duas datas separadamente através das propriedades `p-start-date` e `p-end-date` no lugar do
 * `[(ngModel)]`, no entanto sem a validação do formulário;
 * - Para a validação do formulário, utilize o `[(ngModel)]`.
 */
export declare abstract class PoDatepickerRangeBaseComponent implements ControlValueAccessor, Validator {
    protected poDateService: PoDateService;
    errorMessage: string;
    private _clean?;
    private _disabled?;
    private _endDate?;
    private _literals?;
    private _noAutocomplete?;
    private _readonly;
    private _required?;
    private _startDate?;
    private onChangeModel;
    private validatorChange;
    protected dateRange: PoDatepickerRange;
    protected format: any;
    protected isDateRangeInputFormatValid: boolean;
    protected isStartDateRangeInputValid: boolean;
    protected onTouchedModel: any;
    get isDateRangeInputValid(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Aplica foco no elemento ao ser iniciado.
     *
     * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
     *
     * @default `false`
     */
    autoFocus: boolean;
    /**
     * @optional
     *
     * @description
     *
     * Habilita ação para limpar o campo.
     *
     * @default `false`
     */
    set clean(clean: boolean);
    get clean(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Desabilita o campo.
     *
     * @default `false`
     */
    set disabled(value: boolean);
    get disabled(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Data final.
     */
    set endDate(date: string | Date);
    get endDate(): string | Date;
    /**
     * @optional
     *
     * @description
     *
     * Texto de apoio do campo.
     */
    help?: string;
    /**
     * @optional
     *
     * @description
     *
     * Rótulo do campo.
     */
    label?: string;
    /**
     * @optional
     *
     * @description
     *
     * Objeto com as literais usadas no `po-datepicker-range`.
     *
     * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
     *
     * ```
     *  const customLiterals: PoDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format',
     *    startDateGreaterThanEndDate: 'End date less than start date'
     *  };
     * ```
     *
     * Ou passando apenas as literais que deseja customizar:
     *
     * ```
     *  const customLiterals: PoDatepickerRangeLiterals = {
     *    invalidFormat: 'Date in inconsistent format'
     *  };
     * ```
     *
     * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
     *
     * ```
     * <po-datepicker-range
     *   [p-literals]="customLiterals">
     * </po-datepicker-range>
     * ```
     *
     * > O objeto padrão de literais será traduzido de acordo com o idioma do browser (pt, en, es).
     */
    set literals(value: PoDatepickerRangeLiterals);
    get literals(): PoDatepickerRangeLiterals;
    /**
     * @optional
     *
     * @description
     *
     * Define a propriedade nativa `autocomplete` do campo como `off`.
     *
     * @default `false`
     */
    set noAutocomplete(value: boolean);
    get noAutocomplete(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Define se a indicação de campo opcional será exibida.
     *
     * > Não será exibida a indicação se:
     * - O campo conter `p-required`;
     * - Não possuir `p-help` e/ou `p-label`.
     *
     * @default `false`
     */
    optional: boolean;
    /**
     * @optional
     *
     * @description
     *
     * Indica que o campo será somente leitura.
     *
     * @default `false`
     */
    set readonly(value: boolean);
    get readonly(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Indica que o campo será obrigatório.
     *
     * @default `false`
     */
    set required(required: boolean);
    get required(): boolean;
    /**
     * @optional
     *
     * @description
     *
     * Data inicial.
     */
    set startDate(date: string | Date);
    get startDate(): string | Date;
    /**
     * @optional
     *
     * @description
     *
     * Evento disparado ao alterar valor do campo.
     */
    onChange?: EventEmitter<any>;
    constructor(poDateService: PoDateService);
    protected abstract resetDateRangeInputValidation(): void;
    protected abstract updateScreenByModel(dateRange: PoDatepickerRange): any;
    registerOnChange(func: any): void;
    registerOnTouched(func: any): void;
    registerOnValidatorChange?(fn: () => void): void;
    validate(control: AbstractControl): ValidationErrors;
    writeValue(dateRange: PoDatepickerRange): void;
    protected dateFormatFailed(value: string): boolean;
    protected updateModel(value: any): void;
    protected validateModel(value: any): void;
    private convertPatternDateFormat;
    private dateRangeFailed;
    private dateRangeFormatFailed;
    private dateRangeObjectFailed;
    private isDateRangeObject;
    private requiredDateRangeFailed;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PoDatepickerRangeBaseComponent, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<PoDatepickerRangeBaseComponent, never, never, { "autoFocus": "p-auto-focus"; "clean": "p-clean"; "disabled": "p-disabled"; "endDate": "p-end-date"; "literals": "p-literals"; "noAutocomplete": "p-no-autocomplete"; "readonly": "p-readonly"; "required": "p-required"; "startDate": "p-start-date"; "help": "p-help"; "label": "p-label"; "optional": "p-optional"; }, { "onChange": "p-change"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZGF0ZXBpY2tlci1yYW5nZS1iYXNlLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJwby1kYXRlcGlja2VyLXJhbmdlLWJhc2UuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFBvRGF0ZXBpY2tlclJhbmdlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3BvLWRhdGVwaWNrZXItcmFuZ2UuaW50ZXJmYWNlJztcclxuaW1wb3J0IHsgUG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscyB9IGZyb20gJy4vaW50ZXJmYWNlcy9wby1kYXRlcGlja2VyLXJhbmdlLWxpdGVyYWxzLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IFBvRGF0ZVNlcnZpY2UgfSBmcm9tICcuLy4uLy4uLy4uL3NlcnZpY2VzL3BvLWRhdGUvcG8tZGF0ZS5zZXJ2aWNlJztcclxuZXhwb3J0IGRlY2xhcmUgY29uc3QgcG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFsc0RlZmF1bHQ6IHtcclxuICAgIGVuOiBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzO1xyXG4gICAgZXM6IFBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHM7XHJcbiAgICBwdDogUG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscztcclxuICAgIHJ1OiBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzO1xyXG59O1xyXG4vKipcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqXHJcbiAqIE8gYHBvLWRhdGVwaWNrZXItcmFuZ2VgIMOpIHVtIGNvbXBvbmVudGUgcGFyYSBzZWxlw6fDo28gZGUgdW0gcGVyw61vZG8gZW50cmUgZHVhcyBkYXRhcywgb25kZSDDqSBwb3Nzw612ZWwgaW5mb3JtYXIgYXBlbmFzXHJcbiAqIGEgZGF0YSBpbmljaWFsIG91IGEgZGF0YSBmaW5hbC5cclxuICpcclxuICogTyBjb21wb25lbnRlIGBbKG5nTW9kZWwpXWAgZG8gYHBvLWRhdGVwaWNrZXItcmFuZ2VgIHRyYWJhbGhhIGNvbSB1bSBvYmpldG8gcXVlIGltcGxlbWVudGEgYSBpbnRlcmZhY2VcclxuICogYFBvRGF0ZXBpY2tlclJhbmdlYCwgY29udGVuZG8gYXMgc2VndWludGVzIHByb3ByaWVkYWRlczpcclxuICogYGBgXHJcbiAqIHsgXCJzdGFydFwiOiAnMjAxNy0xMS0yOCcsIFwiZW5kXCI6ICcyMDE3LTExLTMwJyB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiA8YSBpZD1cImFjY2VwdGVkLWZvcm1hdHNcIj48L2E+XHJcbiAqIEVzdGUgY29tcG9uZW50ZSBwb2RlIHJlY2ViZXIgb3Mgc2VndWludGVzIGZvcm1hdG9zIGRlIGRhdGE6XHJcbiAqXHJcbiAqIC0gKipEYXRhIGUgaG9yYSBjb21iaW5hZG9zIChFODYwMURadyk6IHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbSoqXHJcbiAqIGBgYFxyXG4gKiAnMjAxNy0xMS0yOFQwMDowMDowMC0wMjowMCc7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAtICoqRGF0YSAoRTg2MDFEQXcuKTogeXl5eS1tbS1kZCoqXHJcbiAqIGBgYFxyXG4gKiAnMjAxNy0xMS0yOCc7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiAtICoqSmF2YVNjcmlwdCBEYXRlIE9iamVjdDoqKlxyXG4gKiBgYGBcclxuICogbmV3IERhdGUoMjAxNywgMTAsIDI4KTtcclxuICogYGBgXHJcbiAqXHJcbiAqID4gTyBjb21wb25lbnRlIHJlc3BlaXRhcsOhIG8gZm9ybWF0byBwYXNzYWRvIHBhcmEgbyAqbW9kZWwqIHZpYSBjb2RpZmljYcOnw6NvLiBQb3LDqW0sIGNhc28gc2VqYSBmZWl0YSBhbHRlcmHDp8OjbyBlbSBhbGd1bVxyXG4gKiBkb3MgdmFsb3JlcyBkZSBkYXRhIGVtIHRlbGEsIG8gY29tcG9uZW50ZSBhdHJpYnVpcsOhIG8gZm9ybWF0byAqKkRhdGEgKEU4NjAxREF3Lik6IHl5eXktbW0tZGQqKiBhbyBtb2RlbC5cclxuICpcclxuICogSW1wb3J0YW50ZTpcclxuICpcclxuICogLSBRdWFuZG8gcHJlZW5jaGlkYXMgYSBkYXRhIGluaWNpYWwgZSBmaW5hbCwgYSBkYXRhIGluaWNpYWwgZGV2ZSBzZXIgc2VtcHJlIG1lbm9yIG91IGlndWFsIGEgZGF0YSBmaW5hbDtcclxuICogLSBBbyBwYXNzYXIgdW1hIGRhdGEgaW52w6FsaWRhIHZpYSBjb2RpZmljYcOnw6NvLCBvIHZhbG9yIHNlcsOhIG1hbnRpZG8gbm8gKm1vZGVsKiBlIG8gYGlucHV0YCBkYSB0ZWxhIGFwYXJlY2Vyw6EgdmF6aW87XHJcbiAqIC0gUGVybWl0ZSB0cmFiYWxoYXIgY29tIGFzIGR1YXMgZGF0YXMgc2VwYXJhZGFtZW50ZSBhdHJhdsOpcyBkYXMgcHJvcHJpZWRhZGVzIGBwLXN0YXJ0LWRhdGVgIGUgYHAtZW5kLWRhdGVgIG5vIGx1Z2FyIGRvXHJcbiAqIGBbKG5nTW9kZWwpXWAsIG5vIGVudGFudG8gc2VtIGEgdmFsaWRhw6fDo28gZG8gZm9ybXVsw6FyaW87XHJcbiAqIC0gUGFyYSBhIHZhbGlkYcOnw6NvIGRvIGZvcm11bMOhcmlvLCB1dGlsaXplIG8gYFsobmdNb2RlbCldYC5cclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIFBvRGF0ZXBpY2tlclJhbmdlQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xyXG4gICAgcHJvdGVjdGVkIHBvRGF0ZVNlcnZpY2U6IFBvRGF0ZVNlcnZpY2U7XHJcbiAgICBlcnJvck1lc3NhZ2U6IHN0cmluZztcclxuICAgIHByaXZhdGUgX2NsZWFuPztcclxuICAgIHByaXZhdGUgX2Rpc2FibGVkPztcclxuICAgIHByaXZhdGUgX2VuZERhdGU/O1xyXG4gICAgcHJpdmF0ZSBfbGl0ZXJhbHM/O1xyXG4gICAgcHJpdmF0ZSBfbm9BdXRvY29tcGxldGU/O1xyXG4gICAgcHJpdmF0ZSBfcmVhZG9ubHk7XHJcbiAgICBwcml2YXRlIF9yZXF1aXJlZD87XHJcbiAgICBwcml2YXRlIF9zdGFydERhdGU/O1xyXG4gICAgcHJpdmF0ZSBvbkNoYW5nZU1vZGVsO1xyXG4gICAgcHJpdmF0ZSB2YWxpZGF0b3JDaGFuZ2U7XHJcbiAgICBwcm90ZWN0ZWQgZGF0ZVJhbmdlOiBQb0RhdGVwaWNrZXJSYW5nZTtcclxuICAgIHByb3RlY3RlZCBmb3JtYXQ6IGFueTtcclxuICAgIHByb3RlY3RlZCBpc0RhdGVSYW5nZUlucHV0Rm9ybWF0VmFsaWQ6IGJvb2xlYW47XHJcbiAgICBwcm90ZWN0ZWQgaXNTdGFydERhdGVSYW5nZUlucHV0VmFsaWQ6IGJvb2xlYW47XHJcbiAgICBwcm90ZWN0ZWQgb25Ub3VjaGVkTW9kZWw6IGFueTtcclxuICAgIGdldCBpc0RhdGVSYW5nZUlucHV0VmFsaWQoKTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQG9wdGlvbmFsXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQXBsaWNhIGZvY28gbm8gZWxlbWVudG8gYW8gc2VyIGluaWNpYWRvLlxyXG4gICAgICpcclxuICAgICAqID4gQ2FzbyBtYWlzIGRlIHVtIGVsZW1lbnRvIHNlamEgY29uZmlndXJhZG8gY29tIGVzc2EgcHJvcHJpZWRhZGUsIGFwZW5hcyBvIMO6bHRpbW8gZWxlbWVudG8gZGVjbGFyYWRvIGNvbSBlbGEgdGVyw6EgbyBmb2NvLlxyXG4gICAgICpcclxuICAgICAqIEBkZWZhdWx0IGBmYWxzZWBcclxuICAgICAqL1xyXG4gICAgYXV0b0ZvY3VzOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAb3B0aW9uYWxcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqXHJcbiAgICAgKiBIYWJpbGl0YSBhw6fDo28gcGFyYSBsaW1wYXIgbyBjYW1wby5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXHJcbiAgICAgKi9cclxuICAgIHNldCBjbGVhbihjbGVhbjogYm9vbGVhbik7XHJcbiAgICBnZXQgY2xlYW4oKTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQG9wdGlvbmFsXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogRGVzYWJpbGl0YSBvIGNhbXBvLlxyXG4gICAgICpcclxuICAgICAqIEBkZWZhdWx0IGBmYWxzZWBcclxuICAgICAqL1xyXG4gICAgc2V0IGRpc2FibGVkKHZhbHVlOiBib29sZWFuKTtcclxuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAb3B0aW9uYWxcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqXHJcbiAgICAgKiBEYXRhIGZpbmFsLlxyXG4gICAgICovXHJcbiAgICBzZXQgZW5kRGF0ZShkYXRlOiBzdHJpbmcgfCBEYXRlKTtcclxuICAgIGdldCBlbmREYXRlKCk6IHN0cmluZyB8IERhdGU7XHJcbiAgICAvKipcclxuICAgICAqIEBvcHRpb25hbFxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqIFRleHRvIGRlIGFwb2lvIGRvIGNhbXBvLlxyXG4gICAgICovXHJcbiAgICBoZWxwPzogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAb3B0aW9uYWxcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqXHJcbiAgICAgKiBSw7N0dWxvIGRvIGNhbXBvLlxyXG4gICAgICovXHJcbiAgICBsYWJlbD86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogQG9wdGlvbmFsXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogT2JqZXRvIGNvbSBhcyBsaXRlcmFpcyB1c2FkYXMgbm8gYHBvLWRhdGVwaWNrZXItcmFuZ2VgLlxyXG4gICAgICpcclxuICAgICAqIEV4aXN0ZW0gZHVhcyBtYW5laXJhcyBkZSBjdXN0b21pemFyIG8gY29tcG9uZW50ZSwgcGFzc2FuZG8gdW0gb2JqZXRvIGNvbSB0b2RhcyBhcyBsaXRlcmFpcyBkaXNwb27DrXZlaXM6XHJcbiAgICAgKlxyXG4gICAgICogYGBgXHJcbiAgICAgKiAgY29uc3QgY3VzdG9tTGl0ZXJhbHM6IFBvRGF0ZXBpY2tlclJhbmdlTGl0ZXJhbHMgPSB7XHJcbiAgICAgKiAgICBpbnZhbGlkRm9ybWF0OiAnRGF0ZSBpbiBpbmNvbnNpc3RlbnQgZm9ybWF0JyxcclxuICAgICAqICAgIHN0YXJ0RGF0ZUdyZWF0ZXJUaGFuRW5kRGF0ZTogJ0VuZCBkYXRlIGxlc3MgdGhhbiBzdGFydCBkYXRlJ1xyXG4gICAgICogIH07XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBPdSBwYXNzYW5kbyBhcGVuYXMgYXMgbGl0ZXJhaXMgcXVlIGRlc2VqYSBjdXN0b21pemFyOlxyXG4gICAgICpcclxuICAgICAqIGBgYFxyXG4gICAgICogIGNvbnN0IGN1c3RvbUxpdGVyYWxzOiBQb0RhdGVwaWNrZXJSYW5nZUxpdGVyYWxzID0ge1xyXG4gICAgICogICAgaW52YWxpZEZvcm1hdDogJ0RhdGUgaW4gaW5jb25zaXN0ZW50IGZvcm1hdCdcclxuICAgICAqICB9O1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogRSBwYXJhIGNhcnJlZ2FyIGFzIGxpdGVyYWlzIGN1c3RvbWl6YWRhcywgYmFzdGEgYXBlbmFzIHBhc3NhciBvIG9iamV0byBwYXJhIG8gY29tcG9uZW50ZS5cclxuICAgICAqXHJcbiAgICAgKiBgYGBcclxuICAgICAqIDxwby1kYXRlcGlja2VyLXJhbmdlXHJcbiAgICAgKiAgIFtwLWxpdGVyYWxzXT1cImN1c3RvbUxpdGVyYWxzXCI+XHJcbiAgICAgKiA8L3BvLWRhdGVwaWNrZXItcmFuZ2U+XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiA+IE8gb2JqZXRvIHBhZHLDo28gZGUgbGl0ZXJhaXMgc2Vyw6EgdHJhZHV6aWRvIGRlIGFjb3JkbyBjb20gbyBpZGlvbWEgZG8gYnJvd3NlciAocHQsIGVuLCBlcykuXHJcbiAgICAgKi9cclxuICAgIHNldCBsaXRlcmFscyh2YWx1ZTogUG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscyk7XHJcbiAgICBnZXQgbGl0ZXJhbHMoKTogUG9EYXRlcGlja2VyUmFuZ2VMaXRlcmFscztcclxuICAgIC8qKlxyXG4gICAgICogQG9wdGlvbmFsXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogRGVmaW5lIGEgcHJvcHJpZWRhZGUgbmF0aXZhIGBhdXRvY29tcGxldGVgIGRvIGNhbXBvIGNvbW8gYG9mZmAuXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHQgYGZhbHNlYFxyXG4gICAgICovXHJcbiAgICBzZXQgbm9BdXRvY29tcGxldGUodmFsdWU6IGJvb2xlYW4pO1xyXG4gICAgZ2V0IG5vQXV0b2NvbXBsZXRlKCk6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIEBvcHRpb25hbFxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqIERlZmluZSBzZSBhIGluZGljYcOnw6NvIGRlIGNhbXBvIG9wY2lvbmFsIHNlcsOhIGV4aWJpZGEuXHJcbiAgICAgKlxyXG4gICAgICogPiBOw6NvIHNlcsOhIGV4aWJpZGEgYSBpbmRpY2HDp8OjbyBzZTpcclxuICAgICAqIC0gTyBjYW1wbyBjb250ZXIgYHAtcmVxdWlyZWRgO1xyXG4gICAgICogLSBOw6NvIHBvc3N1aXIgYHAtaGVscGAgZS9vdSBgcC1sYWJlbGAuXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHQgYGZhbHNlYFxyXG4gICAgICovXHJcbiAgICBvcHRpb25hbDogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQG9wdGlvbmFsXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogSW5kaWNhIHF1ZSBvIGNhbXBvIHNlcsOhIHNvbWVudGUgbGVpdHVyYS5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXHJcbiAgICAgKi9cclxuICAgIHNldCByZWFkb25seSh2YWx1ZTogYm9vbGVhbik7XHJcbiAgICBnZXQgcmVhZG9ubHkoKTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQG9wdGlvbmFsXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogSW5kaWNhIHF1ZSBvIGNhbXBvIHNlcsOhIG9icmlnYXTDs3Jpby5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdCBgZmFsc2VgXHJcbiAgICAgKi9cclxuICAgIHNldCByZXF1aXJlZChyZXF1aXJlZDogYm9vbGVhbik7XHJcbiAgICBnZXQgcmVxdWlyZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogQG9wdGlvbmFsXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogRGF0YSBpbmljaWFsLlxyXG4gICAgICovXHJcbiAgICBzZXQgc3RhcnREYXRlKGRhdGU6IHN0cmluZyB8IERhdGUpO1xyXG4gICAgZ2V0IHN0YXJ0RGF0ZSgpOiBzdHJpbmcgfCBEYXRlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAb3B0aW9uYWxcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqXHJcbiAgICAgKiBFdmVudG8gZGlzcGFyYWRvIGFvIGFsdGVyYXIgdmFsb3IgZG8gY2FtcG8uXHJcbiAgICAgKi9cclxuICAgIG9uQ2hhbmdlPzogRXZlbnRFbWl0dGVyPGFueT47XHJcbiAgICBjb25zdHJ1Y3Rvcihwb0RhdGVTZXJ2aWNlOiBQb0RhdGVTZXJ2aWNlKTtcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCByZXNldERhdGVSYW5nZUlucHV0VmFsaWRhdGlvbigpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHVwZGF0ZVNjcmVlbkJ5TW9kZWwoZGF0ZVJhbmdlOiBQb0RhdGVwaWNrZXJSYW5nZSk6IGFueTtcclxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZnVuYzogYW55KTogdm9pZDtcclxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZ1bmM6IGFueSk6IHZvaWQ7XHJcbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlPyhmbjogKCkgPT4gdm9pZCk6IHZvaWQ7XHJcbiAgICB2YWxpZGF0ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzO1xyXG4gICAgd3JpdGVWYWx1ZShkYXRlUmFuZ2U6IFBvRGF0ZXBpY2tlclJhbmdlKTogdm9pZDtcclxuICAgIHByb3RlY3RlZCBkYXRlRm9ybWF0RmFpbGVkKHZhbHVlOiBzdHJpbmcpOiBib29sZWFuO1xyXG4gICAgcHJvdGVjdGVkIHVwZGF0ZU1vZGVsKHZhbHVlOiBhbnkpOiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIHZhbGlkYXRlTW9kZWwodmFsdWU6IGFueSk6IHZvaWQ7XHJcbiAgICBwcml2YXRlIGNvbnZlcnRQYXR0ZXJuRGF0ZUZvcm1hdDtcclxuICAgIHByaXZhdGUgZGF0ZVJhbmdlRmFpbGVkO1xyXG4gICAgcHJpdmF0ZSBkYXRlUmFuZ2VGb3JtYXRGYWlsZWQ7XHJcbiAgICBwcml2YXRlIGRhdGVSYW5nZU9iamVjdEZhaWxlZDtcclxuICAgIHByaXZhdGUgaXNEYXRlUmFuZ2VPYmplY3Q7XHJcbiAgICBwcml2YXRlIHJlcXVpcmVkRGF0ZVJhbmdlRmFpbGVkO1xyXG59XHJcbiJdfQ==