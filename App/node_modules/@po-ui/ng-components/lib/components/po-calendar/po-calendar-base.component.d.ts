import { EventEmitter } from '@angular/core';
import { PoCalendarLangService } from './services/po-calendar.lang.service';
import { PoDateService } from '../../services/po-date';
/**
 * @description
 *
 * O `po-calendar` é um componente para seleção de datas. Ele permite uma fácil navegação clicando nas setas
 * de direcionamento e nos *labels* do ano ou mês.
 *
 * Este componente pode receber os seguintes formatos de data:
 *
 * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
 * ```
 * this.date = '2017-11-28T00:00:00-02:00';
 * ```
 *
 * - **Data (E8601DAw.): yyyy-mm-dd**
 * ```
 * this.date = '2017-11-28';
 * ```
 *
 * - **JavaScript Date Object:**
 * ```
 * this.date = new Date(2017, 10, 28);
 * ```
 *
 * > Independentemente do formato utilizado, o componente trata o valor do *model* internamente com o
 * formato **Data (E8601DAw.): yyyy-mm-dd**.
 *
 * Importante:
 *
 * - Caso seja definida uma data fora do range da data mínima e data máxima via *ngModel* o componente mostrará
 * a data desabilitada porém o *model* não será alterado.
 * - Caso seja definida uma data inválida a mesma não será atribuída ao calendário porém o *model* manterá a data inválida.
 */
import * as ɵngcc0 from '@angular/core';
export declare class PoCalendarBaseComponent {
    poDate: PoDateService;
    poCalendarLangService: PoCalendarLangService;
    private _locale;
    private _maxDate;
    private _minDate;
    currentYear: number;
    dayVisible: boolean;
    displayDays: Array<number>;
    displayDecade: Array<number>;
    displayFinalDecade: number;
    displayMonth: any;
    displayMonthNumber: number;
    displayMonths: Array<any>;
    displayStartDecade: number;
    displayWeekDays: Array<any>;
    displayYear: number;
    monthVisible: boolean;
    yearVisible: boolean;
    protected currentMonthNumber: number;
    protected date: Date;
    protected dateIso: string;
    protected lastDisplay: string;
    protected onTouched: any;
    protected propagateChange: any;
    protected today: Date;
    protected validatorChange: any;
    /**
     * @optional
     *
     * @description
     *
     * Idioma do calendário.
     *
     * Valores válidos:
     *  - `pt`
     *  - `en`
     *  - `es`
     *
     * @default `pt`
     */
    set locale(locale: string);
    get locale(): string;
    /**
     * @optional
     *
     * @description
     *
     * Define a data máxima possível de ser selecionada.
     *
     * Pode receber os seguintes formatos de data:
     *
     * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
     * ```
     * this.date = '2017-11-28T00:00:00-02:00';
     * ```
     *
     * - **Data (E8601DAw.): yyyy-mm-dd**
     * ```
     * this.date = '2017-11-28';
     * ```
     *
     * - **JavaScript Date Object:**
     * ```
     * this.date = new Date(2017, 10, 28);
     * ```
     */
    set maxDate(maxDate: any);
    get maxDate(): any;
    /**
     * @optional
     *
     * @description
     *
     * Define a data mínima possível de ser selecionada.
     *
     * Pode receber os seguintes formatos de data:
     *
     * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
     * ```
     * this.date = '2017-11-28T00:00:00-02:00';
     * ```
     *
     * - **Data (E8601DAw.): yyyy-mm-dd**
     * ```
     * this.date = '2017-11-28';
     * ```
     *
     * - **JavaScript Date Object:**
     * ```
     * this.date = new Date(2017, 10, 28);
     * ```
     */
    set minDate(minDate: any);
    get minDate(): any;
    /** Evento disparado ao selecionar um dia do calendário. */
    change: EventEmitter<string>;
    constructor(poDate: PoDateService, poCalendarLangService: PoCalendarLangService);
    initializeLanguage(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PoCalendarBaseComponent, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<PoCalendarBaseComponent, never, never, { "locale": "p-locale"; "maxDate": "p-max-date"; "minDate": "p-min-date"; }, { "change": "p-change"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tY2FsZW5kYXItYmFzZS5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsicG8tY2FsZW5kYXItYmFzZS5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUG9DYWxlbmRhckxhbmdTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9wby1jYWxlbmRhci5sYW5nLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBQb0RhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvcG8tZGF0ZSc7XHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICpcclxuICogTyBgcG8tY2FsZW5kYXJgIMOpIHVtIGNvbXBvbmVudGUgcGFyYSBzZWxlw6fDo28gZGUgZGF0YXMuIEVsZSBwZXJtaXRlIHVtYSBmw6FjaWwgbmF2ZWdhw6fDo28gY2xpY2FuZG8gbmFzIHNldGFzXHJcbiAqIGRlIGRpcmVjaW9uYW1lbnRvIGUgbm9zICpsYWJlbHMqIGRvIGFubyBvdSBtw6pzLlxyXG4gKlxyXG4gKiBFc3RlIGNvbXBvbmVudGUgcG9kZSByZWNlYmVyIG9zIHNlZ3VpbnRlcyBmb3JtYXRvcyBkZSBkYXRhOlxyXG4gKlxyXG4gKiAtICoqRGF0YSBlIGhvcmEgY29tYmluYWRvcyAoRTg2MDFEWncpOiB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW0qKlxyXG4gKiBgYGBcclxuICogdGhpcy5kYXRlID0gJzIwMTctMTEtMjhUMDA6MDA6MDAtMDI6MDAnO1xyXG4gKiBgYGBcclxuICpcclxuICogLSAqKkRhdGEgKEU4NjAxREF3Lik6IHl5eXktbW0tZGQqKlxyXG4gKiBgYGBcclxuICogdGhpcy5kYXRlID0gJzIwMTctMTEtMjgnO1xyXG4gKiBgYGBcclxuICpcclxuICogLSAqKkphdmFTY3JpcHQgRGF0ZSBPYmplY3Q6KipcclxuICogYGBgXHJcbiAqIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKDIwMTcsIDEwLCAyOCk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiA+IEluZGVwZW5kZW50ZW1lbnRlIGRvIGZvcm1hdG8gdXRpbGl6YWRvLCBvIGNvbXBvbmVudGUgdHJhdGEgbyB2YWxvciBkbyAqbW9kZWwqIGludGVybmFtZW50ZSBjb20gb1xyXG4gKiBmb3JtYXRvICoqRGF0YSAoRTg2MDFEQXcuKTogeXl5eS1tbS1kZCoqLlxyXG4gKlxyXG4gKiBJbXBvcnRhbnRlOlxyXG4gKlxyXG4gKiAtIENhc28gc2VqYSBkZWZpbmlkYSB1bWEgZGF0YSBmb3JhIGRvIHJhbmdlIGRhIGRhdGEgbcOtbmltYSBlIGRhdGEgbcOheGltYSB2aWEgKm5nTW9kZWwqIG8gY29tcG9uZW50ZSBtb3N0cmFyw6FcclxuICogYSBkYXRhIGRlc2FiaWxpdGFkYSBwb3LDqW0gbyAqbW9kZWwqIG7Do28gc2Vyw6EgYWx0ZXJhZG8uXHJcbiAqIC0gQ2FzbyBzZWphIGRlZmluaWRhIHVtYSBkYXRhIGludsOhbGlkYSBhIG1lc21hIG7Do28gc2Vyw6EgYXRyaWJ1w61kYSBhbyBjYWxlbmTDoXJpbyBwb3LDqW0gbyAqbW9kZWwqIG1hbnRlcsOhIGEgZGF0YSBpbnbDoWxpZGEuXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBQb0NhbGVuZGFyQmFzZUNvbXBvbmVudCB7XHJcbiAgICBwb0RhdGU6IFBvRGF0ZVNlcnZpY2U7XHJcbiAgICBwb0NhbGVuZGFyTGFuZ1NlcnZpY2U6IFBvQ2FsZW5kYXJMYW5nU2VydmljZTtcclxuICAgIHByaXZhdGUgX2xvY2FsZTtcclxuICAgIHByaXZhdGUgX21heERhdGU7XHJcbiAgICBwcml2YXRlIF9taW5EYXRlO1xyXG4gICAgY3VycmVudFllYXI6IG51bWJlcjtcclxuICAgIGRheVZpc2libGU6IGJvb2xlYW47XHJcbiAgICBkaXNwbGF5RGF5czogQXJyYXk8bnVtYmVyPjtcclxuICAgIGRpc3BsYXlEZWNhZGU6IEFycmF5PG51bWJlcj47XHJcbiAgICBkaXNwbGF5RmluYWxEZWNhZGU6IG51bWJlcjtcclxuICAgIGRpc3BsYXlNb250aDogYW55O1xyXG4gICAgZGlzcGxheU1vbnRoTnVtYmVyOiBudW1iZXI7XHJcbiAgICBkaXNwbGF5TW9udGhzOiBBcnJheTxhbnk+O1xyXG4gICAgZGlzcGxheVN0YXJ0RGVjYWRlOiBudW1iZXI7XHJcbiAgICBkaXNwbGF5V2Vla0RheXM6IEFycmF5PGFueT47XHJcbiAgICBkaXNwbGF5WWVhcjogbnVtYmVyO1xyXG4gICAgbW9udGhWaXNpYmxlOiBib29sZWFuO1xyXG4gICAgeWVhclZpc2libGU6IGJvb2xlYW47XHJcbiAgICBwcm90ZWN0ZWQgY3VycmVudE1vbnRoTnVtYmVyOiBudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgZGF0ZTogRGF0ZTtcclxuICAgIHByb3RlY3RlZCBkYXRlSXNvOiBzdHJpbmc7XHJcbiAgICBwcm90ZWN0ZWQgbGFzdERpc3BsYXk6IHN0cmluZztcclxuICAgIHByb3RlY3RlZCBvblRvdWNoZWQ6IGFueTtcclxuICAgIHByb3RlY3RlZCBwcm9wYWdhdGVDaGFuZ2U6IGFueTtcclxuICAgIHByb3RlY3RlZCB0b2RheTogRGF0ZTtcclxuICAgIHByb3RlY3RlZCB2YWxpZGF0b3JDaGFuZ2U6IGFueTtcclxuICAgIC8qKlxyXG4gICAgICogQG9wdGlvbmFsXHJcbiAgICAgKlxyXG4gICAgICogQGRlc2NyaXB0aW9uXHJcbiAgICAgKlxyXG4gICAgICogSWRpb21hIGRvIGNhbGVuZMOhcmlvLlxyXG4gICAgICpcclxuICAgICAqIFZhbG9yZXMgdsOhbGlkb3M6XHJcbiAgICAgKiAgLSBgcHRgXHJcbiAgICAgKiAgLSBgZW5gXHJcbiAgICAgKiAgLSBgZXNgXHJcbiAgICAgKlxyXG4gICAgICogQGRlZmF1bHQgYHB0YFxyXG4gICAgICovXHJcbiAgICBzZXQgbG9jYWxlKGxvY2FsZTogc3RyaW5nKTtcclxuICAgIGdldCBsb2NhbGUoKTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAb3B0aW9uYWxcclxuICAgICAqXHJcbiAgICAgKiBAZGVzY3JpcHRpb25cclxuICAgICAqXHJcbiAgICAgKiBEZWZpbmUgYSBkYXRhIG3DoXhpbWEgcG9zc8OtdmVsIGRlIHNlciBzZWxlY2lvbmFkYS5cclxuICAgICAqXHJcbiAgICAgKiBQb2RlIHJlY2ViZXIgb3Mgc2VndWludGVzIGZvcm1hdG9zIGRlIGRhdGE6XHJcbiAgICAgKlxyXG4gICAgICogLSAqKkRhdGEgZSBob3JhIGNvbWJpbmFkb3MgKEU4NjAxRFp3KTogeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tKipcclxuICAgICAqIGBgYFxyXG4gICAgICogdGhpcy5kYXRlID0gJzIwMTctMTEtMjhUMDA6MDA6MDAtMDI6MDAnO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogLSAqKkRhdGEgKEU4NjAxREF3Lik6IHl5eXktbW0tZGQqKlxyXG4gICAgICogYGBgXHJcbiAgICAgKiB0aGlzLmRhdGUgPSAnMjAxNy0xMS0yOCc7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiAtICoqSmF2YVNjcmlwdCBEYXRlIE9iamVjdDoqKlxyXG4gICAgICogYGBgXHJcbiAgICAgKiB0aGlzLmRhdGUgPSBuZXcgRGF0ZSgyMDE3LCAxMCwgMjgpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHNldCBtYXhEYXRlKG1heERhdGU6IGFueSk7XHJcbiAgICBnZXQgbWF4RGF0ZSgpOiBhbnk7XHJcbiAgICAvKipcclxuICAgICAqIEBvcHRpb25hbFxyXG4gICAgICpcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICpcclxuICAgICAqIERlZmluZSBhIGRhdGEgbcOtbmltYSBwb3Nzw612ZWwgZGUgc2VyIHNlbGVjaW9uYWRhLlxyXG4gICAgICpcclxuICAgICAqIFBvZGUgcmVjZWJlciBvcyBzZWd1aW50ZXMgZm9ybWF0b3MgZGUgZGF0YTpcclxuICAgICAqXHJcbiAgICAgKiAtICoqRGF0YSBlIGhvcmEgY29tYmluYWRvcyAoRTg2MDFEWncpOiB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW0qKlxyXG4gICAgICogYGBgXHJcbiAgICAgKiB0aGlzLmRhdGUgPSAnMjAxNy0xMS0yOFQwMDowMDowMC0wMjowMCc7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiAtICoqRGF0YSAoRTg2MDFEQXcuKTogeXl5eS1tbS1kZCoqXHJcbiAgICAgKiBgYGBcclxuICAgICAqIHRoaXMuZGF0ZSA9ICcyMDE3LTExLTI4JztcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIC0gKipKYXZhU2NyaXB0IERhdGUgT2JqZWN0OioqXHJcbiAgICAgKiBgYGBcclxuICAgICAqIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKDIwMTcsIDEwLCAyOCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgc2V0IG1pbkRhdGUobWluRGF0ZTogYW55KTtcclxuICAgIGdldCBtaW5EYXRlKCk6IGFueTtcclxuICAgIC8qKiBFdmVudG8gZGlzcGFyYWRvIGFvIHNlbGVjaW9uYXIgdW0gZGlhIGRvIGNhbGVuZMOhcmlvLiAqL1xyXG4gICAgY2hhbmdlOiBFdmVudEVtaXR0ZXI8c3RyaW5nPjtcclxuICAgIGNvbnN0cnVjdG9yKHBvRGF0ZTogUG9EYXRlU2VydmljZSwgcG9DYWxlbmRhckxhbmdTZXJ2aWNlOiBQb0NhbGVuZGFyTGFuZ1NlcnZpY2UpO1xyXG4gICAgaW5pdGlhbGl6ZUxhbmd1YWdlKCk6IHZvaWQ7XHJcbn1cclxuIl19