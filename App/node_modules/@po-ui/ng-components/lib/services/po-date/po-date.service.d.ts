/**
 * @docsPrivate
 *
 * @description
 *
 * Serviço responsável por gerenciar o tratamento dos formatos de data e hora.
 */
import * as ɵngcc0 from '@angular/core';
export declare class PoDateService {
    private readonly dateRegex;
    private readonly isoRegex;
    /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param minDate Definir `true` caso seja `minDate`.
     * @param maxDate Definir `true` caso seja `maxDate`.
     */
    convertIsoToDate(dateString: string, minDate: boolean, maxDate: boolean): Date;
    /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param date Data no formato `Date`.
     */
    convertDateToISO(date: Date): string;
    /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param year Ano a ser validado.
     */
    formatYear(year: number): string;
    /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param isoDate Ano em formato string.
     */
    getDateFromIso(isoDate: string): {
        year: number;
        month: number;
        day: number;
    };
    /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     */
    getDateForDateRange(date: any, isMinDate: boolean): Date;
    /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param dateA primeira data
     * @param dateB segunda data
     */
    isDateRangeValid(dateA?: string, dateB?: string): boolean;
    /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param stringDate Data.
     */
    isValidIso(stringDate: string): boolean;
    /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param date Data.
     * @param year .
     */
    setYearFrom0To100(date: Date, year: number): void;
    /**
     * Método responsável por ordenar duas datas.
     *
     * @param leftSide Primeira data a ser comparada.
     * @param rightSide Segunda data a ser comparada.
     * @param ascending Determina se será em ordem crescente ou decrescente.
     */
    sortDate(leftSide: string | Date, rightSide: string | Date, ascending: boolean): number;
    /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param date Valor da data.
     */
    splitDate(date: Date): {
        year: number;
        month: number;
        day: number;
    };
    /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param date Data a ser validada.
     * @param minDate Data inicial.
     * @param maxDate Data final.
     */
    validateDateRange(date: Date, minDate: Date, maxDate: Date): boolean;
    /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @param date Data que será validada.
     */
    private validateDate;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PoDateService, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<PoDateService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZGF0ZS5zZXJ2aWNlLmQudHMiLCJzb3VyY2VzIjpbInBvLWRhdGUuc2VydmljZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGRvY3NQcml2YXRlXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKlxyXG4gKiBTZXJ2acOnbyByZXNwb25zw6F2ZWwgcG9yIGdlcmVuY2lhciBvIHRyYXRhbWVudG8gZG9zIGZvcm1hdG9zIGRlIGRhdGEgZSBob3JhLlxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUG9EYXRlU2VydmljZSB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRhdGVSZWdleDtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgaXNvUmVnZXg7XHJcbiAgICAvKipcclxuICAgICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBjb252ZXJ0ZXIgZGF0YXMgZG8gZm9ybWF0byBgeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tYCBwYXJhIG8gZm9ybWF0byBgRGF0ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGVTdHJpbmcgRGF0YSBubyBmb3JtYXRvIGB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW1gLlxyXG4gICAgICogQHBhcmFtIG1pbkRhdGUgRGVmaW5pciBgdHJ1ZWAgY2FzbyBzZWphIGBtaW5EYXRlYC5cclxuICAgICAqIEBwYXJhbSBtYXhEYXRlIERlZmluaXIgYHRydWVgIGNhc28gc2VqYSBgbWF4RGF0ZWAuXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRJc29Ub0RhdGUoZGF0ZVN0cmluZzogc3RyaW5nLCBtaW5EYXRlOiBib29sZWFuLCBtYXhEYXRlOiBib29sZWFuKTogRGF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGNvbnZlcnRlciBkYXRhIGRvIGZvcm1hdG8gYERhdGVgIHBhcmEgbyBmb3JtYXRvIGB5eXl5LW1tLWRkYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0ZSBEYXRhIG5vIGZvcm1hdG8gYERhdGVgLlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0RGF0ZVRvSVNPKGRhdGU6IERhdGUpOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBhZGljaW9uYXIgemVyb3MgYSBlc3F1ZXJkYSBkbyBhbm9zIGVtIGZvcm1hdG8gc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB5ZWFyIEFubyBhIHNlciB2YWxpZGFkby5cclxuICAgICAqL1xyXG4gICAgZm9ybWF0WWVhcih5ZWFyOiBudW1iZXIpOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciByZXRvcm5hciBvIGRpYSwgbcOqcyBlIGFubyBzZXBhcmFkb3MgZW0gZm9ybWF0byBkZSBvYmpldG8uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlzb0RhdGUgQW5vIGVtIGZvcm1hdG8gc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBnZXREYXRlRnJvbUlzbyhpc29EYXRlOiBzdHJpbmcpOiB7XHJcbiAgICAgICAgeWVhcjogbnVtYmVyO1xyXG4gICAgICAgIG1vbnRoOiBudW1iZXI7XHJcbiAgICAgICAgZGF5OiBudW1iZXI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgcmV0b3JuYXIgYSBkYXRhIGNvbSBhIGhvcmEgZGVmaW5pZGEgcGFyYSBgMDA6MDA6MDBgIGNhc28gYGlzTWluRGF0ZWAgZm9yIGlndWFsIGEgYHRydWVgIG91IGAyMzo1OTo1OWBcclxuICAgICAqIGNhc28gYGlzTWluZGF0ZWAgc2VqYSBpZ3VhbCBhIGBmYWxzZWAgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRlIERhdGEgbm8gZm9ybWF0byBgRGF0ZWAgb3UgYHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbWAuXHJcbiAgICAgKiBAcGFyYW0gaXNNaW5EYXRlIENhc28gYHRydWVgIGFwbGljYSBgMDA6MDA6MDBgLCBjYXNvIGBmYWxzZWAgYXBsaWNhIGAyMzo1OTo1OWAgYSBob3JhIGRhIGRhdGEgaW5mb3JtYWRhLlxyXG4gICAgICovXHJcbiAgICBnZXREYXRlRm9yRGF0ZVJhbmdlKGRhdGU6IGFueSwgaXNNaW5EYXRlOiBib29sZWFuKTogRGF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0b3JuYSBgdHJ1ZWAgY2FzbyBvIHBlcsOtb2RvIHNlamEgdsOhbGlkbywgcGFyYSBpc3NvIGEgcHJpbWVpcmEgZGF0YSBkZXZlIHNlciBtYWlvciBxdWUgYSBzZWd1bmRhIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gZGF0ZUEgcHJpbWVpcmEgZGF0YVxyXG4gICAgICogQHBhcmFtIGRhdGVCIHNlZ3VuZGEgZGF0YVxyXG4gICAgICovXHJcbiAgICBpc0RhdGVSYW5nZVZhbGlkKGRhdGVBPzogc3RyaW5nLCBkYXRlQj86IHN0cmluZyk6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciB2YWxpZGFyIHNlIHVtYSBkYXRhIGVzdMOhIG5vIGZvcm1hdG8gYHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbWAgb3UgYHl5eXktbW0tZGRgLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdHJpbmdEYXRlIERhdGEuXHJcbiAgICAgKi9cclxuICAgIGlzVmFsaWRJc28oc3RyaW5nRGF0ZTogc3RyaW5nKTogYm9vbGVhbjtcclxuICAgIC8qKlxyXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGNvcnJpZ2lyIGEgZGF0YSBjYXNvIGEgbWVzbWEgZXN0ZWphIGVudHJlIG9zIGFub3MgMCBlIDk5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRlIERhdGEuXHJcbiAgICAgKiBAcGFyYW0geWVhciAuXHJcbiAgICAgKi9cclxuICAgIHNldFllYXJGcm9tMFRvMTAwKGRhdGU6IERhdGUsIHllYXI6IG51bWJlcik6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBvcmRlbmFyIGR1YXMgZGF0YXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxlZnRTaWRlIFByaW1laXJhIGRhdGEgYSBzZXIgY29tcGFyYWRhLlxyXG4gICAgICogQHBhcmFtIHJpZ2h0U2lkZSBTZWd1bmRhIGRhdGEgYSBzZXIgY29tcGFyYWRhLlxyXG4gICAgICogQHBhcmFtIGFzY2VuZGluZyBEZXRlcm1pbmEgc2Ugc2Vyw6EgZW0gb3JkZW0gY3Jlc2NlbnRlIG91IGRlY3Jlc2NlbnRlLlxyXG4gICAgICovXHJcbiAgICBzb3J0RGF0ZShsZWZ0U2lkZTogc3RyaW5nIHwgRGF0ZSwgcmlnaHRTaWRlOiBzdHJpbmcgfCBEYXRlLCBhc2NlbmRpbmc6IGJvb2xlYW4pOiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciByZXRvcm5hciBvIGRpYSAsIG3DqnMgZSBhbm8gZGUgdW1hIGRhdGEgaW5mb3JtYWRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRlIFZhbG9yIGRhIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIHNwbGl0RGF0ZShkYXRlOiBEYXRlKToge1xyXG4gICAgICAgIHllYXI6IG51bWJlcjtcclxuICAgICAgICBtb250aDogbnVtYmVyO1xyXG4gICAgICAgIGRheTogbnVtYmVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHZhbGlkYXIgc2UgdW1hIGRhdGEgZXN0w6EgZW50cmUgYSBgbWluRGF0ZWAgZSBgbWF4RGF0ZWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGUgRGF0YSBhIHNlciB2YWxpZGFkYS5cclxuICAgICAqIEBwYXJhbSBtaW5EYXRlIERhdGEgaW5pY2lhbC5cclxuICAgICAqIEBwYXJhbSBtYXhEYXRlIERhdGEgZmluYWwuXHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlRGF0ZVJhbmdlKGRhdGU6IERhdGUsIG1pbkRhdGU6IERhdGUsIG1heERhdGU6IERhdGUpOiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgdmFsaWRhciBzZSBhIGRhdGEgZm9pIGluZm9ybWFkYSBub3MgcGFkcsO1ZXMgJ3l5eXktbW0tZGQnLCAneXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tJyBvdVxyXG4gICAgICogJ0RhdGUnIHBhZHLDo28gZG8gamF2YXNjcmlwdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0ZSBEYXRhIHF1ZSBzZXLDoSB2YWxpZGFkYS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZURhdGU7XHJcbn1cclxuIl19